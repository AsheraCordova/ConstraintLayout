//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\motion\widget\MLMotionConstrainedPoint.java
//

#define J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION 1




#include "ConstraintAttribute.h"
#include "ConstraintSet.h"
#include "Easing.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "Key.h"
#include "Log.h"
#include "MLMotionConstrainedPoint.h"
#include "Rect.h"
#include "View.h"
#include "ViewSpline.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/LinkedHashMap.h"
#include "java/util/Set.h"




#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic ignored "-Wswitch"


@interface ADXMLMotionConstrainedPoint () {
 @public
  float alpha_;
  bool applyElevation_;
  float elevation_;
  float rotation_;
  float rotationX_;
  float scaleX_;
  float scaleY_;
  float mPivotX_;
  float mPivotY_;
  float translationX_;
  float translationY_;
  float translationZ_;
  ADXEasing *mKeyFrameEasing_;
  int32_t mDrawPath_;
  float position_;
  float x_;
  float y_;
  float width_;
  float height_;
  float mPathRotate_;
  float mProgress_;
  int32_t mAnimateRelativeTo_;
}

- (bool)diffWithFloat:(float)a
            withFloat:(float)b;

@end

J2OBJC_FIELD_SETTER(ADXMLMotionConstrainedPoint, mKeyFrameEasing_, ADXEasing *)

__attribute__((unused)) static bool ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(ADXMLMotionConstrainedPoint *self, float a, float b);

J2OBJC_INITIALIZED_DEFN(ADXMLMotionConstrainedPoint)

NSString *ADXMLMotionConstrainedPoint_TAG = @"MLMotionPaths";
IOSObjectArray *ADXMLMotionConstrainedPoint_names;

@implementation ADXMLMotionConstrainedPoint

- (instancetype)initPackagePrivate {
  ADXMLMotionConstrainedPoint_initPackagePrivate(self);
  return self;
}

- (bool)diffWithFloat:(float)a
            withFloat:(float)b {
  return ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, a, b);
}

- (void)differentWithADXMLMotionConstrainedPoint:(ADXMLMotionConstrainedPoint *)points
                             withJavaUtilHashSet:(JavaUtilHashSet *)keySet {
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, alpha_, ((ADXMLMotionConstrainedPoint *) nil_chk(points))->alpha_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_ALPHA];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, elevation_, points->elevation_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_ELEVATION];
  }
  if (visibility_ != points->visibility_ && mVisibilityMode_ == ADXConstraintSet_VISIBILITY_MODE_NORMAL && (visibility_ == ADXConstraintSet_VISIBLE || points->visibility_ == ADXConstraintSet_VISIBLE)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_ALPHA];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, rotation_, points->rotation_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_ROTATION];
  }
  if (!(JavaLangFloat_isNaNWithFloat_(mPathRotate_) && JavaLangFloat_isNaNWithFloat_(points->mPathRotate_))) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_TRANSITION_PATH_ROTATE];
  }
  if (!(JavaLangFloat_isNaNWithFloat_(mProgress_) && JavaLangFloat_isNaNWithFloat_(points->mProgress_))) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_PROGRESS];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, rotationX_, points->rotationX_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_ROTATION_X];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, rotationY_, points->rotationY_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_ROTATION_Y];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, mPivotX_, points->mPivotX_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_PIVOT_X];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, mPivotY_, points->mPivotY_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_PIVOT_Y];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, scaleX_, points->scaleX_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_SCALE_X];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, scaleY_, points->scaleY_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_SCALE_Y];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, translationX_, points->translationX_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_TRANSLATION_X];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, translationY_, points->translationY_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_TRANSLATION_Y];
  }
  if (ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, translationZ_, points->translationZ_)) {
    [((JavaUtilHashSet *) nil_chk(keySet)) addWithId:ADXKey_TRANSLATION_Z];
  }
}

- (void)differentWithADXMLMotionConstrainedPoint:(ADXMLMotionConstrainedPoint *)points
                                withBooleanArray:(IOSBooleanArray *)mask
                               withNSStringArray:(IOSObjectArray *)custom {
  int32_t c = 0;
  *IOSBooleanArray_GetRef(nil_chk(mask), c++) |= ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, position_, ((ADXMLMotionConstrainedPoint *) nil_chk(points))->position_);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, x_, points->x_);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, y_, points->y_);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, width_, points->width_);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(self, height_, points->height_);
}

- (void)fillStandardWithDoubleArray:(IOSDoubleArray *)data
                       withIntArray:(IOSIntArray *)toUse {
  IOSFloatArray *set = [IOSFloatArray arrayWithFloats:(float[]){ position_, x_, y_, width_, height_, alpha_, elevation_, rotation_, rotationX_, rotationY_, scaleX_, scaleY_, mPivotX_, mPivotY_, translationX_, translationY_, translationZ_, mPathRotate_ } count:18];
  int32_t c = 0;
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    if (IOSIntArray_Get(toUse, i) < set->size_) {
      *IOSDoubleArray_GetRef(nil_chk(data), c++) = IOSFloatArray_Get(set, IOSIntArray_Get(toUse, i));
    }
  }
}

- (bool)hasCustomDataWithNSString:(NSString *)name {
  return [((JavaUtilLinkedHashMap *) nil_chk(attributes_)) containsKeyWithId:name];
}

- (int32_t)getCustomDataCountWithNSString:(NSString *)name {
  return [((ADXConstraintAttribute *) nil_chk([((JavaUtilLinkedHashMap *) nil_chk(attributes_)) getWithId:name])) numberOfInterpolatedValues];
}

- (int32_t)getCustomDataWithNSString:(NSString *)name
                     withDoubleArray:(IOSDoubleArray *)value
                             withInt:(int32_t)offset {
  ADXConstraintAttribute *a = JreRetainedLocalValue([((JavaUtilLinkedHashMap *) nil_chk(attributes_)) getWithId:name]);
  if ([((ADXConstraintAttribute *) nil_chk(a)) numberOfInterpolatedValues] == 1) {
    *IOSDoubleArray_GetRef(nil_chk(value), offset) = [a getValueToInterpolate];
    return 1;
  }
  else {
    int32_t N = [a numberOfInterpolatedValues];
    IOSFloatArray *f = [IOSFloatArray arrayWithLength:N];
    [a getValuesToInterpolateWithFloatArray:f];
    for (int32_t i = 0; i < N; i++) {
      *IOSDoubleArray_GetRef(nil_chk(value), offset++) = IOSFloatArray_Get(f, i);
    }
    return N;
  }
}

- (void)setBoundsWithFloat:(float)x
                 withFloat:(float)y
                 withFloat:(float)w
                 withFloat:(float)h {
  self->x_ = x;
  self->y_ = y;
  width_ = w;
  height_ = h;
}

- (int32_t)compareToWithId:(ADXMLMotionConstrainedPoint *)o {
  cast_chk(o, [ADXMLMotionConstrainedPoint class]);
  return JavaLangFloat_compareWithFloat_withFloat_(position_, ((ADXMLMotionConstrainedPoint *) nil_chk(o))->position_);
}

- (void)applyParametersWithADView:(ADView *)view {
  self->visibility_ = [((ADView *) nil_chk(view)) getVisibility];
  self->alpha_ = ([view getVisibility] != ADView_VISIBLE) ? 0.0f : [view getAlpha];
  self->applyElevation_ = false;
  {
    self->elevation_ = [view getElevation];
  }
  self->rotation_ = [view getRotation];
  self->rotationX_ = [view getRotationX];
  self->rotationY_ = [view getRotationY];
  self->scaleX_ = [view getScaleX];
  self->scaleY_ = [view getScaleY];
  self->mPivotX_ = [view getPivotX];
  self->mPivotY_ = [view getPivotY];
  self->translationX_ = [view getTranslationX];
  self->translationY_ = [view getTranslationY];
  {
    self->translationZ_ = [view getTranslationZ];
  }
}

- (void)applyParametersWithADXConstraintSet_Constraint:(ADXConstraintSet_Constraint *)c {
  self->mVisibilityMode_ = ((ADXConstraintSet_PropertySet *) nil_chk(((ADXConstraintSet_Constraint *) nil_chk(c))->propertySet_))->mVisibilityMode_;
  self->visibility_ = c->propertySet_->visibility_;
  self->alpha_ = (c->propertySet_->visibility_ != ADXConstraintSet_VISIBLE && mVisibilityMode_ == ADXConstraintSet_VISIBILITY_MODE_NORMAL) ? 0.0f : c->propertySet_->alpha_;
  self->applyElevation_ = ((ADXConstraintSet_Transform *) nil_chk(c->transform_))->applyElevation_;
  self->elevation_ = c->transform_->elevation_;
  self->rotation_ = c->transform_->rotation_;
  self->rotationX_ = c->transform_->rotationX_;
  self->rotationY_ = c->transform_->rotationY_;
  self->scaleX_ = c->transform_->scaleX_;
  self->scaleY_ = c->transform_->scaleY_;
  self->mPivotX_ = c->transform_->transformPivotX_;
  self->mPivotY_ = c->transform_->transformPivotY_;
  self->translationX_ = c->transform_->translationX_;
  self->translationY_ = c->transform_->translationY_;
  self->translationZ_ = c->transform_->translationZ_;
  JreStrongAssign(&self->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(((ADXConstraintSet_Motion *) nil_chk(c->motion_))->mTransitionEasing_));
  self->mPathRotate_ = c->motion_->mPathRotate_;
  self->mDrawPath_ = c->motion_->mDrawPath_;
  self->mAnimateRelativeTo_ = c->motion_->mAnimateRelativeTo_;
  self->mProgress_ = c->propertySet_->mProgress_;
  id<JavaUtilSet> at = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(c->mCustomConstraints_)) keySet]);
  for (NSString * __strong s in nil_chk(at)) {
    ADXConstraintAttribute *attr = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(c->mCustomConstraints_)) getWithId:s]);
    if ([((ADXConstraintAttribute *) nil_chk(attr)) isContinuous]) {
      [((JavaUtilLinkedHashMap *) nil_chk(self->attributes_)) putWithId:s withId:attr];
    }
  }
}

- (void)addValuesWithJavaUtilHashMap:(JavaUtilHashMap *)splines
                             withInt:(int32_t)mFramePosition {
  for (NSString * __strong s in nil_chk([((JavaUtilHashMap *) nil_chk(splines)) keySet])) {
    ADXViewSpline *ViewSpline = JreRetainedLocalValue([splines getWithId:s]);
    switch (JreIndexOfStr(s, (id[]){ ADXKey_ALPHA, ADXKey_ELEVATION, ADXKey_ROTATION, ADXKey_ROTATION_X, ADXKey_ROTATION_Y, ADXKey_PIVOT_X, ADXKey_PIVOT_Y, ADXKey_TRANSITION_PATH_ROTATE, ADXKey_PROGRESS, ADXKey_SCALE_X, ADXKey_SCALE_Y, ADXKey_TRANSLATION_X, ADXKey_TRANSLATION_Y, ADXKey_TRANSLATION_Z }, 14)) {
      case 0:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(alpha_) ? 1 : alpha_];
      break;
      case 1:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(elevation_) ? 0 : elevation_];
      break;
      case 2:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(rotation_) ? 0 : rotation_];
      break;
      case 3:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(rotationX_) ? 0 : rotationX_];
      break;
      case 4:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(rotationY_) ? 0 : rotationY_];
      break;
      case 5:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(mPivotX_) ? 0 : mPivotX_];
      break;
      case 6:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(mPivotY_) ? 0 : mPivotY_];
      break;
      case 7:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(mPathRotate_) ? 0 : mPathRotate_];
      break;
      case 8:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(mProgress_) ? 0 : mProgress_];
      break;
      case 9:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(scaleX_) ? 1 : scaleX_];
      break;
      case 10:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(scaleY_) ? 1 : scaleY_];
      break;
      case 11:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(translationX_) ? 0 : translationX_];
      break;
      case 12:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(translationY_) ? 0 : translationY_];
      break;
      case 13:
      [((ADXViewSpline *) nil_chk(ViewSpline)) setPointWithInt:mFramePosition withFloat:JavaLangFloat_isNaNWithFloat_(translationZ_) ? 0 : translationZ_];
      break;
      default:
      if ([((NSString *) nil_chk(s)) java_hasPrefix:@"CUSTOM"]) {
        NSString *customName = IOSObjectArray_Get(nil_chk([s java_split:@","]), 1);
        if ([((JavaUtilLinkedHashMap *) nil_chk(attributes_)) containsKeyWithId:customName]) {
          ADXConstraintAttribute *custom = JreRetainedLocalValue([((JavaUtilLinkedHashMap *) nil_chk(attributes_)) getWithId:customName]);
          if ([ViewSpline isKindOfClass:[ADXViewSpline_CustomSet class]]) {
            [((ADXViewSpline_CustomSet *) nil_chk(((ADXViewSpline_CustomSet *) ViewSpline))) setPointWithInt:mFramePosition withADXConstraintAttribute:custom];
          }
          else {
            ADLog_eWithNSString_withNSString_(ADXMLMotionConstrainedPoint_TAG, JreStrcat("$$I$F@", s, @" ViewSpline not a CustomSet frame = ", mFramePosition, @", value", [((ADXConstraintAttribute *) nil_chk(custom)) getValueToInterpolate], ViewSpline));
          }
        }
      }
      else {
        ADLog_eWithNSString_withNSString_(ADXMLMotionConstrainedPoint_TAG, JreStrcat("$$", @"UNKNOWN spline ", s));
      }
    }
  }
}

- (void)setStateWithADView:(ADView *)view {
  [self setBoundsWithFloat:[((ADView *) nil_chk(view)) getX] withFloat:[view getY] withFloat:[view getWidth] withFloat:[view getHeight]];
  [self applyParametersWithADView:view];
}

- (void)setStateWithADRect:(ADRect *)rect
                withADView:(ADView *)view
                   withInt:(int32_t)rotation
                 withFloat:(float)prevous {
  [self setBoundsWithFloat:((ADRect *) nil_chk(rect))->left_ withFloat:rect->top_ withFloat:[rect width] withFloat:[rect height]];
  [self applyParametersWithADView:view];
  mPivotX_ = JavaLangFloat_NaN;
  mPivotY_ = JavaLangFloat_NaN;
  switch (rotation) {
    case ADXConstraintSet_ROTATE_PORTRATE_OF_LEFT:
    self->rotation_ = prevous + 90;
    break;
    case ADXConstraintSet_ROTATE_PORTRATE_OF_RIGHT:
    self->rotation_ = prevous - 90;
    break;
  }
}

- (void)setStateWithADRect:(ADRect *)cw
      withADXConstraintSet:(ADXConstraintSet *)constraintSet
                   withInt:(int32_t)rotation
                   withInt:(int32_t)viewId {
  [self setBoundsWithFloat:((ADRect *) nil_chk(cw))->left_ withFloat:cw->top_ withFloat:[cw width] withFloat:[cw height]];
  [self applyParametersWithADXConstraintSet_Constraint:[((ADXConstraintSet *) nil_chk(constraintSet)) getParametersWithInt:viewId]];
  switch (rotation) {
    case ADXConstraintSet_ROTATE_PORTRATE_OF_RIGHT:
    case ADXConstraintSet_ROTATE_RIGHT_OF_PORTRATE:
    JreMinusAssignFloatF(&self->rotation_, 90);
    break;
    case ADXConstraintSet_ROTATE_PORTRATE_OF_LEFT:
    case ADXConstraintSet_ROTATE_LEFT_OF_PORTRATE:
    JrePlusAssignFloatF(&self->rotation_, 90);
    if (self->rotation_ > 180) JreMinusAssignFloatF(&self->rotation_, 360);
    break;
  }
}

- (void)dealloc {
  RELEASE_(mKeyFrameEasing_);
  RELEASE_(attributes_);
  RELEASE_(mTempValue_);
  RELEASE_(mTempDelta_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 2, 3, -1, 4, -1, -1 },
    { NULL, "V", 0x0, 2, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 6, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 8, 9, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 10, 9, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 13, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 20, 21, -1, 22, -1, -1 },
    { NULL, "V", 0x1, 23, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 23, 25, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initPackagePrivate);
  methods[1].selector = @selector(diffWithFloat:withFloat:);
  methods[2].selector = @selector(differentWithADXMLMotionConstrainedPoint:withJavaUtilHashSet:);
  methods[3].selector = @selector(differentWithADXMLMotionConstrainedPoint:withBooleanArray:withNSStringArray:);
  methods[4].selector = @selector(fillStandardWithDoubleArray:withIntArray:);
  methods[5].selector = @selector(hasCustomDataWithNSString:);
  methods[6].selector = @selector(getCustomDataCountWithNSString:);
  methods[7].selector = @selector(getCustomDataWithNSString:withDoubleArray:withInt:);
  methods[8].selector = @selector(setBoundsWithFloat:withFloat:withFloat:withFloat:);
  methods[9].selector = @selector(compareToWithId:);
  methods[10].selector = @selector(applyParametersWithADView:);
  methods[11].selector = @selector(applyParametersWithADXConstraintSet_Constraint:);
  methods[12].selector = @selector(addValuesWithJavaUtilHashMap:withInt:);
  methods[13].selector = @selector(setStateWithADView:);
  methods[14].selector = @selector(setStateWithADRect:withADView:withInt:withFloat:);
  methods[15].selector = @selector(setStateWithADRect:withADXConstraintSet:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 26, -1, -1 },
    { "DEBUG", "Z", .constantValue.asBOOL = ADXMLMotionConstrainedPoint_DEBUG, 0x19, -1, -1, -1, -1 },
    { "alpha_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mVisibilityMode_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "visibility_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "applyElevation_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "elevation_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "rotation_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "rotationX_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "rotationY_", "F", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "scaleX_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "scaleY_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPivotX_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPivotY_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "translationX_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "translationY_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "translationZ_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mKeyFrameEasing_", "LADXEasing;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDrawPath_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "position_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "y_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "width_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "height_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPathRotate_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mProgress_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAnimateRelativeTo_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "PERPENDICULAR", "I", .constantValue.asInt = ADXMLMotionConstrainedPoint_PERPENDICULAR, 0x18, -1, -1, -1, -1 },
    { "CARTESIAN", "I", .constantValue.asInt = ADXMLMotionConstrainedPoint_CARTESIAN, 0x18, -1, -1, -1, -1 },
    { "names", "[LNSString;", .constantValue.asLong = 0, 0x8, -1, 27, -1, -1 },
    { "attributes_", "LJavaUtilLinkedHashMap;", .constantValue.asLong = 0, 0x0, -1, -1, 28, -1 },
    { "mMode_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTempValue_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTempDelta_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "diff", "FF", "different", "LADXMLMotionConstrainedPoint;LJavaUtilHashSet;", "(Landroidx/constraintlayout/motion/widget/MLMotionConstrainedPoint;Ljava/util/HashSet<Ljava/lang/String;>;)V", "LADXMLMotionConstrainedPoint;[Z[LNSString;", "fillStandard", "[D[I", "hasCustomData", "LNSString;", "getCustomDataCount", "getCustomData", "LNSString;[DI", "setBounds", "FFFF", "compareTo", "LADXMLMotionConstrainedPoint;", "applyParameters", "LADView;", "LADXConstraintSet_Constraint;", "addValues", "LJavaUtilHashMap;I", "(Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/motion/utils/ViewSpline;>;I)V", "setState", "LADRect;LADView;IF", "LADRect;LADXConstraintSet;II", &ADXMLMotionConstrainedPoint_TAG, &ADXMLMotionConstrainedPoint_names, "Ljava/util/LinkedHashMap<Ljava/lang/String;Landroidx/constraintlayout/widget/ConstraintAttribute;>;", "Ljava/lang/Object;Ljava/lang/Comparable<Landroidx/constraintlayout/motion/widget/MLMotionConstrainedPoint;>;" };
  static const J2ObjcClassInfo _ADXMLMotionConstrainedPoint = { "MLMotionConstrainedPoint", "androidx.constraintlayout.motion.widget", ptrTable, methods, fields, 7, 0x0, 16, 34, -1, -1, -1, 29, -1 };
  return &_ADXMLMotionConstrainedPoint;
}

+ (void)initialize {
  if (self == [ADXMLMotionConstrainedPoint class]) {
    JreStrongAssignAndConsume(&ADXMLMotionConstrainedPoint_names, [IOSObjectArray newArrayWithObjects:(id[]){ @"position", @"x", @"y", @"width", @"height", @"pathRotate" } count:6 type:NSString_class_()]);
    J2OBJC_SET_INITIALIZED(ADXMLMotionConstrainedPoint)
  }
}

@end

void ADXMLMotionConstrainedPoint_initPackagePrivate(ADXMLMotionConstrainedPoint *self) {
  NSObject_init(self);
  self->alpha_ = 1;
  self->mVisibilityMode_ = ADXConstraintSet_VISIBILITY_MODE_NORMAL;
  self->applyElevation_ = false;
  self->elevation_ = 0;
  self->rotation_ = 0;
  self->rotationX_ = 0;
  self->rotationY_ = 0;
  self->scaleX_ = 1;
  self->scaleY_ = 1;
  self->mPivotX_ = JavaLangFloat_NaN;
  self->mPivotY_ = JavaLangFloat_NaN;
  self->translationX_ = 0;
  self->translationY_ = 0;
  self->translationZ_ = 0;
  self->mDrawPath_ = 0;
  self->mPathRotate_ = JavaLangFloat_NaN;
  self->mProgress_ = JavaLangFloat_NaN;
  self->mAnimateRelativeTo_ = -1;
  JreStrongAssignAndConsume(&self->attributes_, new_JavaUtilLinkedHashMap_init());
  self->mMode_ = 0;
  JreStrongAssignAndConsume(&self->mTempValue_, [IOSDoubleArray newArrayWithLength:18]);
  JreStrongAssignAndConsume(&self->mTempDelta_, [IOSDoubleArray newArrayWithLength:18]);
}

ADXMLMotionConstrainedPoint *new_ADXMLMotionConstrainedPoint_initPackagePrivate() {
  J2OBJC_NEW_IMPL(ADXMLMotionConstrainedPoint, initPackagePrivate)
}

ADXMLMotionConstrainedPoint *create_ADXMLMotionConstrainedPoint_initPackagePrivate() {
  J2OBJC_CREATE_IMPL(ADXMLMotionConstrainedPoint, initPackagePrivate)
}

bool ADXMLMotionConstrainedPoint_diffWithFloat_withFloat_(ADXMLMotionConstrainedPoint *self, float a, float b) {
  if (JavaLangFloat_isNaNWithFloat_(a) || JavaLangFloat_isNaNWithFloat_(b)) {
    return JavaLangFloat_isNaNWithFloat_(a) != JavaLangFloat_isNaNWithFloat_(b);
  }
  return JavaLangMath_absWithFloat_(a - b) > 0.000001f;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXMLMotionConstrainedPoint)
