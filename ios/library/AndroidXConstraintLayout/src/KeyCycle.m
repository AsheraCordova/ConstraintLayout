//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\motion\widget\KeyCycle.java
//

#include "AttributeSet.h"
#include "CLDebug.h"
#include "ConstraintAttribute.h"
#include "Context.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "Key.h"
#include "KeyCycle.h"
#include "Log.h"
#include "Oscillator.h"
#include "SplineSet.h"
#include "ViewOscillator.h"
#include "ViewSpline.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Set.h"


@interface ADXKeyCycle () {
 @public
  NSString *mTransitionEasing_;
  jint mCurveFit_;
  NSString *mCustomWaveShape_;
  jfloat mProgress_;
  jfloat mAlpha_;
  jfloat mElevation_;
  jfloat mRotation_;
  jfloat mTransitionPathRotate_;
  jfloat mRotationX_;
  jfloat mRotationY_;
  jfloat mScaleX_;
  jfloat mScaleY_;
  jfloat mTranslationX_;
  jfloat mTranslationY_;
  jfloat mTranslationZ_;
}

@end

J2OBJC_FIELD_SETTER(ADXKeyCycle, mTransitionEasing_, NSString *)
J2OBJC_FIELD_SETTER(ADXKeyCycle, mCustomWaveShape_, NSString *)

inline NSString *ADXKeyCycle_get_TAG(void);
static NSString *ADXKeyCycle_TAG = @"KeyCycle";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXKeyCycle, TAG, NSString *)

@interface ADXKeyCycle_Loader : NSObject

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXKeyCycle_Loader)

__attribute__((unused)) static void ADXKeyCycle_Loader_init(ADXKeyCycle_Loader *self);

__attribute__((unused)) static ADXKeyCycle_Loader *new_ADXKeyCycle_Loader_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADXKeyCycle_Loader *create_ADXKeyCycle_Loader_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXKeyCycle_Loader)

NSString *ADXKeyCycle_NAME = @"KeyCycle";
NSString *ADXKeyCycle_WAVE_PERIOD = @"wavePeriod";
NSString *ADXKeyCycle_WAVE_OFFSET = @"waveOffset";
NSString *ADXKeyCycle_WAVE_PHASE = @"wavePhase";
NSString *ADXKeyCycle_WAVE_SHAPE = @"waveShape";

@implementation ADXKeyCycle

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXKeyCycle_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)load__WithADContext:(ADContext *)context
         withADAttributeSet:(ADAttributeSet *)attrs {
}

- (void)getAttributeNamesWithJavaUtilHashSet:(JavaUtilHashSet *)attributes {
  if (!JavaLangFloat_isNaNWithFloat_(mAlpha_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_ALPHA];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mElevation_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_ELEVATION];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mRotation_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_ROTATION];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mRotationX_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_ROTATION_X];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mRotationY_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_ROTATION_Y];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mScaleX_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_SCALE_X];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mScaleY_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_SCALE_Y];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mTransitionPathRotate_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_TRANSITION_PATH_ROTATE];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mTranslationX_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_TRANSLATION_X];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mTranslationY_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_TRANSLATION_Y];
  }
  if (!JavaLangFloat_isNaNWithFloat_(mTranslationZ_)) {
    [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:ADXKey_TRANSLATION_Z];
  }
  if ([((JavaUtilHashMap *) nil_chk(mCustomConstraints_)) size] > 0) {
    for (NSString * __strong s in nil_chk([((JavaUtilHashMap *) nil_chk(mCustomConstraints_)) keySet])) {
      [((JavaUtilHashSet *) nil_chk(attributes)) addWithId:JreStrcat("$C$", ADXKey_CUSTOM, ',', s)];
    }
  }
}

- (void)addCycleValuesWithJavaUtilHashMap:(JavaUtilHashMap *)oscSet {
  for (NSString * __strong key in nil_chk([((JavaUtilHashMap *) nil_chk(oscSet)) keySet])) {
    if ([((NSString *) nil_chk(key)) java_hasPrefix:ADXKey_CUSTOM]) {
      NSString *customKey = [key java_substring:[((NSString *) nil_chk(ADXKey_CUSTOM)) java_length] + 1];
      ADXConstraintAttribute *cValue = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(mCustomConstraints_)) getWithId:customKey]);
      if (cValue == nil || [cValue getType] != JreLoadEnum(ADXConstraintAttribute_AttributeType, FLOAT_TYPE)) {
        continue;
      }
      ADXViewOscillator *osc = JreRetainedLocalValue([oscSet getWithId:key]);
      if (osc == nil) {
        continue;
      }
      [osc setPointWithInt:mFramePosition_ withInt:mWaveShape_ withNSString:mCustomWaveShape_ withInt:mWaveVariesBy_ withFloat:mWavePeriod_ withFloat:mWaveOffset_ withFloat:mWavePhase_ withFloat:[cValue getValueToInterpolate] withId:cValue];
      continue;
    }
    jfloat value = [self getValueWithNSString:key];
    if (JavaLangFloat_isNaNWithFloat_(value)) {
      continue;
    }
    ADXViewOscillator *osc = JreRetainedLocalValue([oscSet getWithId:key]);
    if (osc == nil) {
      continue;
    }
    [osc setPointWithInt:mFramePosition_ withInt:mWaveShape_ withNSString:mCustomWaveShape_ withInt:mWaveVariesBy_ withFloat:mWavePeriod_ withFloat:mWaveOffset_ withFloat:mWavePhase_ withFloat:value];
  }
}

- (jfloat)getValueWithNSString:(NSString *)key {
  switch (JreIndexOfStr(key, (id[]){ ADXKey_ALPHA, ADXKey_ELEVATION, ADXKey_ROTATION, ADXKey_ROTATION_X, ADXKey_ROTATION_Y, ADXKey_TRANSITION_PATH_ROTATE, ADXKey_SCALE_X, ADXKey_SCALE_Y, ADXKey_TRANSLATION_X, ADXKey_TRANSLATION_Y, ADXKey_TRANSLATION_Z, ADXKey_WAVE_OFFSET, ADXKey_WAVE_PHASE, ADXKey_PROGRESS }, 14)) {
    case 0:
    return mAlpha_;
    case 1:
    return mElevation_;
    case 2:
    return mRotation_;
    case 3:
    return mRotationX_;
    case 4:
    return mRotationY_;
    case 5:
    return mTransitionPathRotate_;
    case 6:
    return mScaleX_;
    case 7:
    return mScaleY_;
    case 8:
    return mTranslationX_;
    case 9:
    return mTranslationY_;
    case 10:
    return mTranslationZ_;
    case 11:
    return mWaveOffset_;
    case 12:
    return mWavePhase_;
    case 13:
    return mProgress_;
    default:
    if (![((NSString *) nil_chk(key)) java_hasPrefix:@"CUSTOM"]) {
      ADLog_vWithNSString_withNSString_(@"WARNING! KeyCycle", JreStrcat("$$", @"  UNKNOWN  ", key));
    }
    return JavaLangFloat_NaN;
  }
}

- (void)addValuesWithJavaUtilHashMap:(JavaUtilHashMap *)splines {
  ADXCLDebug_logStackWithNSString_withNSString_withInt_(ADXKeyCycle_TAG, JreStrcat("$I$", @"add ", [((JavaUtilHashMap *) nil_chk(splines)) size], @" values"), 2);
  for (NSString * __strong s in nil_chk([splines keySet])) {
    ADXSplineSet *splineSet = JreRetainedLocalValue([splines getWithId:s]);
    if (splineSet == nil) {
      continue;
    }
    switch (JreIndexOfStr(s, (id[]){ ADXKey_ALPHA, ADXKey_ELEVATION, ADXKey_ROTATION, ADXKey_ROTATION_X, ADXKey_ROTATION_Y, ADXKey_TRANSITION_PATH_ROTATE, ADXKey_SCALE_X, ADXKey_SCALE_Y, ADXKey_TRANSLATION_X, ADXKey_TRANSLATION_Y, ADXKey_TRANSLATION_Z, ADXKey_WAVE_OFFSET, ADXKey_WAVE_PHASE, ADXKey_PROGRESS }, 14)) {
      case 0:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mAlpha_];
      break;
      case 1:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mElevation_];
      break;
      case 2:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mRotation_];
      break;
      case 3:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mRotationX_];
      break;
      case 4:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mRotationY_];
      break;
      case 5:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mTransitionPathRotate_];
      break;
      case 6:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mScaleX_];
      break;
      case 7:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mScaleY_];
      break;
      case 8:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mTranslationX_];
      break;
      case 9:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mTranslationY_];
      break;
      case 10:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mTranslationZ_];
      break;
      case 11:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mWaveOffset_];
      break;
      case 12:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mWavePhase_];
      break;
      case 13:
      [splineSet setPointWithInt:mFramePosition_ withFloat:mProgress_];
      break;
      default:
      if (![((NSString *) nil_chk(s)) java_hasPrefix:@"CUSTOM"]) {
        ADLog_vWithNSString_withNSString_(@"WARNING KeyCycle", JreStrcat("$$", @"  UNKNOWN  ", s));
      }
    }
  }
}

- (void)setValueWithNSString:(NSString *)tag
                      withId:(id)value {
  switch (JreIndexOfStr(tag, (id[]){ ADXKey_ALPHA, ADXKey_CURVEFIT, ADXKey_ELEVATION, ADXKey_MOTIONPROGRESS, ADXKey_ROTATION, ADXKey_ROTATION_X, ADXKey_ROTATION_Y, ADXKey_SCALE_X, ADXKey_SCALE_Y, ADXKey_TRANSITIONEASING, ADXKey_TRANSITION_PATH_ROTATE, ADXKey_TRANSLATION_X, ADXKey_TRANSLATION_Y, ADXKey_TRANSLATION_Z, ADXKeyCycle_WAVE_PERIOD, ADXKeyCycle_WAVE_OFFSET, ADXKeyCycle_WAVE_PHASE, ADXKeyCycle_WAVE_SHAPE }, 18)) {
    case 0:
    mAlpha_ = [self toFloatWithId:value];
    break;
    case 1:
    mCurveFit_ = [self toIntWithId:value];
    break;
    case 2:
    mElevation_ = [self toFloatWithId:value];
    break;
    case 3:
    mProgress_ = [self toFloatWithId:value];
    break;
    case 4:
    mRotation_ = [self toFloatWithId:value];
    break;
    case 5:
    mRotationX_ = [self toFloatWithId:value];
    break;
    case 6:
    mRotationY_ = [self toFloatWithId:value];
    break;
    case 7:
    mScaleX_ = [self toFloatWithId:value];
    break;
    case 8:
    mScaleY_ = [self toFloatWithId:value];
    break;
    case 9:
    JreStrongAssign(&mTransitionEasing_, [nil_chk(value) description]);
    break;
    case 10:
    mTransitionPathRotate_ = [self toFloatWithId:value];
    break;
    case 11:
    mTranslationX_ = [self toFloatWithId:value];
    break;
    case 12:
    mTranslationY_ = [self toFloatWithId:value];
    break;
    case 13:
    mTranslationZ_ = [self toFloatWithId:value];
    break;
    case 14:
    mWavePeriod_ = [self toFloatWithId:value];
    break;
    case 15:
    mWaveOffset_ = [self toFloatWithId:value];
    break;
    case 16:
    mWavePhase_ = [self toFloatWithId:value];
    break;
    case 17:
    if ([value isKindOfClass:[JavaLangInteger class]]) {
      mWaveShape_ = [self toIntWithId:value];
    }
    else {
      mWaveShape_ = ADXOscillator_CUSTOM;
      JreStrongAssign(&mCustomWaveShape_, [nil_chk(value) description]);
    }
    break;
  }
}

- (ADXKey *)copy__WithADXKey:(ADXKey *)src {
  [super copy__WithADXKey:src];
  ADXKeyCycle *k = (ADXKeyCycle *) cast_chk(src, [ADXKeyCycle class]);
  JreStrongAssign(&mTransitionEasing_, ((ADXKeyCycle *) nil_chk(k))->mTransitionEasing_);
  mCurveFit_ = k->mCurveFit_;
  mWaveShape_ = k->mWaveShape_;
  JreStrongAssign(&mCustomWaveShape_, k->mCustomWaveShape_);
  mWavePeriod_ = k->mWavePeriod_;
  mWaveOffset_ = k->mWaveOffset_;
  mWavePhase_ = k->mWavePhase_;
  mProgress_ = k->mProgress_;
  mWaveVariesBy_ = k->mWaveVariesBy_;
  mAlpha_ = k->mAlpha_;
  mElevation_ = k->mElevation_;
  mRotation_ = k->mRotation_;
  mTransitionPathRotate_ = k->mTransitionPathRotate_;
  mRotationX_ = k->mRotationX_;
  mRotationY_ = k->mRotationY_;
  mScaleX_ = k->mScaleX_;
  mScaleY_ = k->mScaleY_;
  mTranslationX_ = k->mTranslationX_;
  mTranslationY_ = k->mTranslationY_;
  mTranslationZ_ = k->mTranslationZ_;
  return self;
}

- (ADXKey *)java_clone {
  return [create_ADXKeyCycle_init() copy__WithADXKey:self];
}

- (void)dealloc {
  RELEASE_(mTransitionEasing_);
  RELEASE_(mCustomWaveShape_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
    { NULL, "V", 0x1, 5, 6, -1, 7, -1, -1 },
    { NULL, "F", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 6, -1, 11, -1, -1 },
    { NULL, "V", 0x1, 12, 13, -1, -1, -1, -1 },
    { NULL, "LADXKey;", 0x1, 14, 15, -1, -1, -1, -1 },
    { NULL, "LADXKey;", 0x1, 16, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(load__WithADContext:withADAttributeSet:);
  methods[2].selector = @selector(getAttributeNamesWithJavaUtilHashSet:);
  methods[3].selector = @selector(addCycleValuesWithJavaUtilHashMap:);
  methods[4].selector = @selector(getValueWithNSString:);
  methods[5].selector = @selector(addValuesWithJavaUtilHashMap:);
  methods[6].selector = @selector(setValueWithNSString:withId:);
  methods[7].selector = @selector(copy__WithADXKey:);
  methods[8].selector = @selector(java_clone);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 17, -1, -1 },
    { "NAME", "LNSString;", .constantValue.asLong = 0, 0x18, -1, 18, -1, -1 },
    { "WAVE_PERIOD", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 19, -1, -1 },
    { "WAVE_OFFSET", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 20, -1, -1 },
    { "WAVE_PHASE", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 21, -1, -1 },
    { "WAVE_SHAPE", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 22, -1, -1 },
    { "SHAPE_SIN_WAVE", "I", .constantValue.asInt = ADXKeyCycle_SHAPE_SIN_WAVE, 0x19, -1, -1, -1, -1 },
    { "SHAPE_SQUARE_WAVE", "I", .constantValue.asInt = ADXKeyCycle_SHAPE_SQUARE_WAVE, 0x19, -1, -1, -1, -1 },
    { "SHAPE_TRIANGLE_WAVE", "I", .constantValue.asInt = ADXKeyCycle_SHAPE_TRIANGLE_WAVE, 0x19, -1, -1, -1, -1 },
    { "SHAPE_SAW_WAVE", "I", .constantValue.asInt = ADXKeyCycle_SHAPE_SAW_WAVE, 0x19, -1, -1, -1, -1 },
    { "SHAPE_REVERSE_SAW_WAVE", "I", .constantValue.asInt = ADXKeyCycle_SHAPE_REVERSE_SAW_WAVE, 0x19, -1, -1, -1, -1 },
    { "SHAPE_COS_WAVE", "I", .constantValue.asInt = ADXKeyCycle_SHAPE_COS_WAVE, 0x19, -1, -1, -1, -1 },
    { "SHAPE_BOUNCE", "I", .constantValue.asInt = ADXKeyCycle_SHAPE_BOUNCE, 0x19, -1, -1, -1, -1 },
    { "mTransitionEasing_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mCurveFit_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mWaveShape_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mCustomWaveShape_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mWavePeriod_", "F", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mWaveOffset_", "F", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mWavePhase_", "F", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mProgress_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mWaveVariesBy_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mAlpha_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mElevation_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mRotation_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTransitionPathRotate_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mRotationX_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mRotationY_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mScaleX_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mScaleY_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTranslationX_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTranslationY_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTranslationZ_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "KEY_TYPE", "I", .constantValue.asInt = ADXKeyCycle_KEY_TYPE, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "load", "LADContext;LADAttributeSet;", "getAttributeNames", "LJavaUtilHashSet;", "(Ljava/util/HashSet<Ljava/lang/String;>;)V", "addCycleValues", "LJavaUtilHashMap;", "(Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/motion/utils/ViewOscillator;>;)V", "getValue", "LNSString;", "addValues", "(Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/motion/utils/ViewSpline;>;)V", "setValue", "LNSString;LNSObject;", "copy", "LADXKey;", "clone", &ADXKeyCycle_TAG, &ADXKeyCycle_NAME, &ADXKeyCycle_WAVE_PERIOD, &ADXKeyCycle_WAVE_OFFSET, &ADXKeyCycle_WAVE_PHASE, &ADXKeyCycle_WAVE_SHAPE, "LADXKeyCycle_Loader;" };
  static const J2ObjcClassInfo _ADXKeyCycle = { "KeyCycle", "androidx.constraintlayout.motion.widget", ptrTable, methods, fields, 7, 0x1, 9, 34, -1, 23, -1, -1, -1 };
  return &_ADXKeyCycle;
}

@end

void ADXKeyCycle_init(ADXKeyCycle *self) {
  ADXKey_init(self);
  JreStrongAssign(&self->mTransitionEasing_, nil);
  self->mCurveFit_ = 0;
  self->mWaveShape_ = -1;
  JreStrongAssign(&self->mCustomWaveShape_, nil);
  self->mWavePeriod_ = JavaLangFloat_NaN;
  self->mWaveOffset_ = 0;
  self->mWavePhase_ = 0;
  self->mProgress_ = JavaLangFloat_NaN;
  self->mWaveVariesBy_ = -1;
  self->mAlpha_ = JavaLangFloat_NaN;
  self->mElevation_ = JavaLangFloat_NaN;
  self->mRotation_ = JavaLangFloat_NaN;
  self->mTransitionPathRotate_ = JavaLangFloat_NaN;
  self->mRotationX_ = JavaLangFloat_NaN;
  self->mRotationY_ = JavaLangFloat_NaN;
  self->mScaleX_ = JavaLangFloat_NaN;
  self->mScaleY_ = JavaLangFloat_NaN;
  self->mTranslationX_ = JavaLangFloat_NaN;
  self->mTranslationY_ = JavaLangFloat_NaN;
  self->mTranslationZ_ = JavaLangFloat_NaN;
  {
    self->mType_ = ADXKeyCycle_KEY_TYPE;
    JreStrongAssignAndConsume(&self->mCustomConstraints_, new_JavaUtilHashMap_init());
  }
}

ADXKeyCycle *new_ADXKeyCycle_init() {
  J2OBJC_NEW_IMPL(ADXKeyCycle, init)
}

ADXKeyCycle *create_ADXKeyCycle_init() {
  J2OBJC_CREATE_IMPL(ADXKeyCycle, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXKeyCycle)

@implementation ADXKeyCycle_Loader

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXKeyCycle_Loader_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LADXKeyCycle;" };
  static const J2ObjcClassInfo _ADXKeyCycle_Loader = { "Loader", "androidx.constraintlayout.motion.widget", ptrTable, methods, NULL, 7, 0xa, 1, 0, 0, -1, -1, -1, -1 };
  return &_ADXKeyCycle_Loader;
}

@end

void ADXKeyCycle_Loader_init(ADXKeyCycle_Loader *self) {
  NSObject_init(self);
}

ADXKeyCycle_Loader *new_ADXKeyCycle_Loader_init() {
  J2OBJC_NEW_IMPL(ADXKeyCycle_Loader, init)
}

ADXKeyCycle_Loader *create_ADXKeyCycle_Loader_init() {
  J2OBJC_CREATE_IMPL(ADXKeyCycle_Loader, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXKeyCycle_Loader)
