//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\core\motion\MotionPaths.java
//

#define J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION 1




#include "CustomVariable.h"
#include "Easing.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "Motion.h"
#include "MotionKeyPosition.h"
#include "MotionPaths.h"
#include "MotionWidget.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/util/Arrays.h"
#include "java/util/HashMap.h"
#include "java/util/Set.h"




#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic ignored "-Wswitch"


@interface ADXMotionPaths ()

+ (float)xRotateWithFloat:(float)sin
                withFloat:(float)cos
                withFloat:(float)cx
                withFloat:(float)cy
                withFloat:(float)x
                withFloat:(float)y;

+ (float)yRotateWithFloat:(float)sin
                withFloat:(float)cos
                withFloat:(float)cx
                withFloat:(float)cy
                withFloat:(float)x
                withFloat:(float)y;

- (bool)diffWithFloat:(float)a
            withFloat:(float)b;

@end

__attribute__((unused)) static float ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(float sin, float cos, float cx, float cy, float x, float y);

__attribute__((unused)) static float ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(float sin, float cos, float cx, float cy, float x, float y);

__attribute__((unused)) static bool ADXMotionPaths_diffWithFloat_withFloat_(ADXMotionPaths *self, float a, float b);

J2OBJC_INITIALIZED_DEFN(ADXMotionPaths)

NSString *ADXMotionPaths_TAG = @"MotionPaths";
IOSObjectArray *ADXMotionPaths_names;

@implementation ADXMotionPaths

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXMotionPaths_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)initCartesianWithADXMotionKeyPosition:(ADXMotionKeyPosition *)c
                           withADXMotionPaths:(ADXMotionPaths *)startTimePoint
                           withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  float position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  ADXMotionPaths *point = self;
  point->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  float scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  float scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  float scaleX = ((ADXMotionPaths *) nil_chk(endTimePoint))->width_ - ((ADXMotionPaths *) nil_chk(startTimePoint))->width_;
  float scaleY = endTimePoint->height_ - startTimePoint->height_;
  point->position_ = point->time_;
  float path = position;
  float startCenterX = startTimePoint->x_ + startTimePoint->width_ / 2;
  float startCenterY = startTimePoint->y_ + startTimePoint->height_ / 2;
  float endCenterX = endTimePoint->x_ + endTimePoint->width_ / 2;
  float endCenterY = endTimePoint->y_ + endTimePoint->height_ / 2;
  float pathVectorX = endCenterX - startCenterX;
  float pathVectorY = endCenterY - startCenterY;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  point->width_ = JreFpToInt((startTimePoint->width_ + scaleX * scaleWidth));
  point->height_ = JreFpToInt((startTimePoint->height_ + scaleY * scaleHeight));
  float dxdx = (JavaLangFloat_isNaNWithFloat_(c->mPercentX_)) ? position : c->mPercentX_;
  float dydx = (JavaLangFloat_isNaNWithFloat_(c->mAltPercentY_)) ? 0 : c->mAltPercentY_;
  float dydy = (JavaLangFloat_isNaNWithFloat_(c->mPercentY_)) ? position : c->mPercentY_;
  float dxdy = (JavaLangFloat_isNaNWithFloat_(c->mAltPercentX_)) ? 0 : c->mAltPercentX_;
  point->mMode_ = ADXMotionPaths_CARTESIAN;
  point->x_ = JreFpToInt((startTimePoint->x_ + pathVectorX * dxdx + pathVectorY * dxdy - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + pathVectorX * dydx + pathVectorY * dydy - scaleY * scaleHeight / 2));
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  point->mPathMotionArc_ = c->mPathMotionArc_;
}

- (instancetype)initWithInt:(int32_t)parentWidth
                    withInt:(int32_t)parentHeight
   withADXMotionKeyPosition:(ADXMotionKeyPosition *)c
         withADXMotionPaths:(ADXMotionPaths *)startTimePoint
         withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(self, parentWidth, parentHeight, c, startTimePoint, endTimePoint);
  return self;
}

- (void)initPolarWithInt:(int32_t)parentWidth
                 withInt:(int32_t)parentHeight
withADXMotionKeyPosition:(ADXMotionKeyPosition *)c
      withADXMotionPaths:(ADXMotionPaths *)s
      withADXMotionPaths:(ADXMotionPaths *)e {
  float position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  self->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  self->mMode_ = c->mPositionType_;
  float scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  float scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  float scaleX = ((ADXMotionPaths *) nil_chk(e))->width_ - ((ADXMotionPaths *) nil_chk(s))->width_;
  float scaleY = e->height_ - s->height_;
  self->position_ = self->time_;
  width_ = JreFpToInt((s->width_ + scaleX * scaleWidth));
  height_ = JreFpToInt((s->height_ + scaleY * scaleHeight));
  float startfactor = 1 - position;
  float endfactor = position;
  switch (c->mPositionType_) {
    case ADXMotionKeyPosition_TYPE_SCREEN:
    self->x_ = JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? (position * (e->x_ - s->x_) + s->x_) : c->mPercentX_ * JavaLangMath_minWithFloat_withFloat_(scaleHeight, scaleWidth);
    self->y_ = JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? (position * (e->y_ - s->y_) + s->y_) : c->mPercentY_;
    break;
    case ADXMotionKeyPosition_TYPE_PATH:
    self->x_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? position : c->mPercentX_) * (e->x_ - s->x_) + s->x_;
    self->y_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? position : c->mPercentY_) * (e->y_ - s->y_) + s->y_;
    break;
    default:
    case ADXMotionKeyPosition_TYPE_CARTESIAN:
    self->x_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? position : c->mPercentX_) * (e->x_ - s->x_) + s->x_;
    self->y_ = (JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? position : c->mPercentY_) * (e->y_ - s->y_) + s->y_;
    break;
  }
  self->mAnimateRelativeTo_ = s->mAnimateRelativeTo_;
  JreStrongAssign(&self->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  self->mPathMotionArc_ = c->mPathMotionArc_;
}

- (void)setupRelativeWithADXMotion:(ADXMotion *)mc
                withADXMotionPaths:(ADXMotionPaths *)relative {
  double dx = x_ + width_ / 2 - ((ADXMotionPaths *) nil_chk(relative))->x_ - relative->width_ / 2;
  double dy = y_ + height_ / 2 - relative->y_ - relative->height_ / 2;
  JreStrongAssign(&mRelativeToController_, mc);
  x_ = (float) JavaLangMath_hypotWithDouble_withDouble_(dy, dx);
  if (JavaLangFloat_isNaNWithFloat_(mRelativeAngle_)) {
    y_ = (float) (JavaLangMath_atan2WithDouble_withDouble_(dy, dx) + JavaLangMath_PI / 2);
  }
  else {
    y_ = (float) JavaLangMath_toRadiansWithDouble_(mRelativeAngle_);
  }
}

- (void)initScreenWithInt:(int32_t)parentWidth
                  withInt:(int32_t)parentHeight
 withADXMotionKeyPosition:(ADXMotionKeyPosition *)c
       withADXMotionPaths:(ADXMotionPaths *)startTimePoint
       withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  float position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  ADXMotionPaths *point = self;
  point->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  float scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  float scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  float scaleX = ((ADXMotionPaths *) nil_chk(endTimePoint))->width_ - ((ADXMotionPaths *) nil_chk(startTimePoint))->width_;
  float scaleY = endTimePoint->height_ - startTimePoint->height_;
  point->position_ = point->time_;
  float path = position;
  float startCenterX = startTimePoint->x_ + startTimePoint->width_ / 2;
  float startCenterY = startTimePoint->y_ + startTimePoint->height_ / 2;
  float endCenterX = endTimePoint->x_ + endTimePoint->width_ / 2;
  float endCenterY = endTimePoint->y_ + endTimePoint->height_ / 2;
  float pathVectorX = endCenterX - startCenterX;
  float pathVectorY = endCenterY - startCenterY;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  point->width_ = JreFpToInt((startTimePoint->width_ + scaleX * scaleWidth));
  point->height_ = JreFpToInt((startTimePoint->height_ + scaleY * scaleHeight));
  point->mMode_ = ADXMotionPaths_SCREEN;
  if (!JavaLangFloat_isNaNWithFloat_(c->mPercentX_)) {
    JreMinusAssignIntF(&parentWidth, point->width_);
    point->x_ = JreFpToInt((c->mPercentX_ * parentWidth));
  }
  if (!JavaLangFloat_isNaNWithFloat_(c->mPercentY_)) {
    JreMinusAssignIntF(&parentHeight, point->height_);
    point->y_ = JreFpToInt((c->mPercentY_ * parentHeight));
  }
  point->mAnimateRelativeTo_ = mAnimateRelativeTo_;
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  point->mPathMotionArc_ = c->mPathMotionArc_;
}

- (void)initPathWithADXMotionKeyPosition:(ADXMotionKeyPosition *)c
                      withADXMotionPaths:(ADXMotionPaths *)startTimePoint
                      withADXMotionPaths:(ADXMotionPaths *)endTimePoint {
  float position = ((ADXMotionKeyPosition *) nil_chk(c))->mFramePosition_ / 100.0f;
  ADXMotionPaths *point = self;
  point->time_ = position;
  mDrawPath_ = c->mDrawPath_;
  float scaleWidth = JavaLangFloat_isNaNWithFloat_(c->mPercentWidth_) ? position : c->mPercentWidth_;
  float scaleHeight = JavaLangFloat_isNaNWithFloat_(c->mPercentHeight_) ? position : c->mPercentHeight_;
  float scaleX = ((ADXMotionPaths *) nil_chk(endTimePoint))->width_ - ((ADXMotionPaths *) nil_chk(startTimePoint))->width_;
  float scaleY = endTimePoint->height_ - startTimePoint->height_;
  point->position_ = point->time_;
  float path = JavaLangFloat_isNaNWithFloat_(c->mPercentX_) ? position : c->mPercentX_;
  float startCenterX = startTimePoint->x_ + startTimePoint->width_ / 2;
  float startCenterY = startTimePoint->y_ + startTimePoint->height_ / 2;
  float endCenterX = endTimePoint->x_ + endTimePoint->width_ / 2;
  float endCenterY = endTimePoint->y_ + endTimePoint->height_ / 2;
  float pathVectorX = endCenterX - startCenterX;
  float pathVectorY = endCenterY - startCenterY;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  point->width_ = JreFpToInt((startTimePoint->width_ + scaleX * scaleWidth));
  point->height_ = JreFpToInt((startTimePoint->height_ + scaleY * scaleHeight));
  float perpendicular = JavaLangFloat_isNaNWithFloat_(c->mPercentY_) ? 0 : c->mPercentY_;
  float perpendicularX = -pathVectorY;
  float perpendicularY = pathVectorX;
  float normalX = perpendicularX * perpendicular;
  float normalY = perpendicularY * perpendicular;
  point->mMode_ = ADXMotionPaths_PERPENDICULAR;
  point->x_ = JreFpToInt((startTimePoint->x_ + (pathVectorX) * path - scaleX * scaleWidth / 2));
  point->y_ = JreFpToInt((startTimePoint->y_ + (pathVectorY) * path - scaleY * scaleHeight / 2));
  JrePlusAssignFloatF(&point->x_, normalX);
  JrePlusAssignFloatF(&point->y_, normalY);
  point->mAnimateRelativeTo_ = mAnimateRelativeTo_;
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(c->mTransitionEasing_));
  point->mPathMotionArc_ = c->mPathMotionArc_;
}

+ (float)xRotateWithFloat:(float)sin
                withFloat:(float)cos
                withFloat:(float)cx
                withFloat:(float)cy
                withFloat:(float)x
                withFloat:(float)y {
  return ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x, y);
}

+ (float)yRotateWithFloat:(float)sin
                withFloat:(float)cos
                withFloat:(float)cx
                withFloat:(float)cy
                withFloat:(float)x
                withFloat:(float)y {
  return ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x, y);
}

- (bool)diffWithFloat:(float)a
            withFloat:(float)b {
  return ADXMotionPaths_diffWithFloat_withFloat_(self, a, b);
}

- (void)differentWithADXMotionPaths:(ADXMotionPaths *)points
                   withBooleanArray:(IOSBooleanArray *)mask
                  withNSStringArray:(IOSObjectArray *)custom
                        withBoolean:(bool)arcMode {
  int32_t c = 0;
  bool diffx = ADXMotionPaths_diffWithFloat_withFloat_(self, x_, ((ADXMotionPaths *) nil_chk(points))->x_);
  bool diffy = ADXMotionPaths_diffWithFloat_withFloat_(self, y_, points->y_);
  *IOSBooleanArray_GetRef(nil_chk(mask), c++) |= ADXMotionPaths_diffWithFloat_withFloat_(self, position_, points->position_);
  *IOSBooleanArray_GetRef(mask, c++) |= (diffx | diffy | arcMode);
  *IOSBooleanArray_GetRef(mask, c++) |= (diffx | diffy | arcMode);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMotionPaths_diffWithFloat_withFloat_(self, width_, points->width_);
  *IOSBooleanArray_GetRef(mask, c++) |= ADXMotionPaths_diffWithFloat_withFloat_(self, height_, points->height_);
}

- (void)getCenterWithDouble:(double)p
               withIntArray:(IOSIntArray *)toUse
            withDoubleArray:(IOSDoubleArray *)data
             withFloatArray:(IOSFloatArray *)point
                    withInt:(int32_t)offset {
  float v_x = x_;
  float v_y = y_;
  float v_width = width_;
  float v_height = height_;
  float translationX = 0;
  float translationY = 0;
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    float value = (float) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:p withFloatArray:pos withFloatArray:vel];
    float rx = IOSFloatArray_Get(pos, 0);
    float ry = IOSFloatArray_Get(pos, 1);
    float radius = v_x;
    float angle = v_y;
    v_x = (float) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (float) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
  }
  *IOSFloatArray_GetRef(nil_chk(point), offset) = v_x + v_width / 2 + translationX;
  *IOSFloatArray_GetRef(point, offset + 1) = v_y + v_height / 2 + translationY;
}

- (void)getCenterWithDouble:(double)p
               withIntArray:(IOSIntArray *)toUse
            withDoubleArray:(IOSDoubleArray *)data
             withFloatArray:(IOSFloatArray *)point
            withDoubleArray:(IOSDoubleArray *)vdata
             withFloatArray:(IOSFloatArray *)velocity {
  float v_x = x_;
  float v_y = y_;
  float v_width = width_;
  float v_height = height_;
  float dv_x = 0;
  float dv_y = 0;
  float dv_width = 0;
  float dv_height = 0;
  float translationX = 0;
  float translationY = 0;
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    float value = (float) IOSDoubleArray_Get(nil_chk(data), i);
    float dvalue = (float) IOSDoubleArray_Get(nil_chk(vdata), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      dv_x = dvalue;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      dv_y = dvalue;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      dv_width = dvalue;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      dv_height = dvalue;
      break;
    }
  }
  float dpos_x = dv_x + dv_width / 2;
  float dpos_y = dv_y + dv_height / 2;
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:p withFloatArray:pos withFloatArray:vel];
    float rx = IOSFloatArray_Get(pos, 0);
    float ry = IOSFloatArray_Get(pos, 1);
    float radius = v_x;
    float angle = v_y;
    float dradius = dv_x;
    float dangle = dv_y;
    float drx = IOSFloatArray_Get(vel, 0);
    float dry = IOSFloatArray_Get(vel, 1);
    v_x = (float) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (float) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
    dpos_x = (float) (drx + dradius * JavaLangMath_sinWithDouble_(angle) + JavaLangMath_cosWithDouble_(angle) * dangle);
    dpos_y = (float) (dry - dradius * JavaLangMath_cosWithDouble_(angle) + JavaLangMath_sinWithDouble_(angle) * dangle);
  }
  *IOSFloatArray_GetRef(nil_chk(point), 0) = v_x + v_width / 2 + translationX;
  *IOSFloatArray_GetRef(point, 1) = v_y + v_height / 2 + translationY;
  *IOSFloatArray_GetRef(nil_chk(velocity), 0) = dpos_x;
  *IOSFloatArray_GetRef(velocity, 1) = dpos_y;
}

- (void)getCenterVelocityWithDouble:(double)p
                       withIntArray:(IOSIntArray *)toUse
                    withDoubleArray:(IOSDoubleArray *)data
                     withFloatArray:(IOSFloatArray *)point
                            withInt:(int32_t)offset {
  float v_x = x_;
  float v_y = y_;
  float v_width = width_;
  float v_height = height_;
  float translationX = 0;
  float translationY = 0;
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    float value = (float) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:p withFloatArray:pos withFloatArray:vel];
    float rx = IOSFloatArray_Get(pos, 0);
    float ry = IOSFloatArray_Get(pos, 1);
    float radius = v_x;
    float angle = v_y;
    v_x = (float) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (float) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
  }
  *IOSFloatArray_GetRef(nil_chk(point), offset) = v_x + v_width / 2 + translationX;
  *IOSFloatArray_GetRef(point, offset + 1) = v_y + v_height / 2 + translationY;
}

- (void)getBoundsWithIntArray:(IOSIntArray *)toUse
              withDoubleArray:(IOSDoubleArray *)data
               withFloatArray:(IOSFloatArray *)point
                      withInt:(int32_t)offset {
  float v_x = x_;
  float v_y = y_;
  float v_width = width_;
  float v_height = height_;
  float translationX = 0;
  float translationY = 0;
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    float value = (float) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  *IOSFloatArray_GetRef(nil_chk(point), offset) = v_width;
  *IOSFloatArray_GetRef(point, offset + 1) = v_height;
}

- (void)setViewWithFloat:(float)position
     withADXMotionWidget:(ADXMotionWidget *)view
            withIntArray:(IOSIntArray *)toUse
         withDoubleArray:(IOSDoubleArray *)data
         withDoubleArray:(IOSDoubleArray *)slope
         withDoubleArray:(IOSDoubleArray *)cycle {
  float v_x = x_;
  float v_y = y_;
  float v_width = width_;
  float v_height = height_;
  float dv_x = 0;
  float dv_y = 0;
  float dv_width = 0;
  float dv_height = 0;
  float delta_path = 0;
  float path_rotate = JavaLangFloat_NaN;
  NSString *mod;
  if (((IOSIntArray *) nil_chk(toUse))->size_ != 0 && ((IOSDoubleArray *) nil_chk(mTempValue_))->size_ <= IOSIntArray_Get(toUse, toUse->size_ - 1)) {
    int32_t scratch_data_length = IOSIntArray_Get(toUse, toUse->size_ - 1) + 1;
    JreStrongAssignAndConsume(&mTempValue_, [IOSDoubleArray newArrayWithLength:scratch_data_length]);
    JreStrongAssignAndConsume(&mTempDelta_, [IOSDoubleArray newArrayWithLength:scratch_data_length]);
  }
  JavaUtilArrays_fillWithDoubleArray_withDouble_(mTempValue_, JavaLangDouble_NaN);
  for (int32_t i = 0; i < toUse->size_; i++) {
    *IOSDoubleArray_GetRef(nil_chk(mTempValue_), IOSIntArray_Get(toUse, i)) = IOSDoubleArray_Get(nil_chk(data), i);
    *IOSDoubleArray_GetRef(nil_chk(mTempDelta_), IOSIntArray_Get(toUse, i)) = IOSDoubleArray_Get(nil_chk(slope), i);
  }
  for (int32_t i = 0; i < ((IOSDoubleArray *) nil_chk(mTempValue_))->size_; i++) {
    if (JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(mTempValue_, i)) && (cycle == nil || IOSDoubleArray_Get(cycle, i) == 0.0)) {
      continue;
    }
    double deltaCycle = (cycle != nil) ? IOSDoubleArray_Get(nil_chk(cycle), i) : 0.0;
    float value = (float) (JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(nil_chk(mTempValue_), i)) ? deltaCycle : IOSDoubleArray_Get(nil_chk(mTempValue_), i) + deltaCycle);
    float dvalue = (float) IOSDoubleArray_Get(nil_chk(mTempDelta_), i);
    switch (i) {
      case ADXMotionPaths_OFF_POSITION:
      delta_path = value;
      break;
      case ADXMotionPaths_OFF_X:
      v_x = value;
      dv_x = dvalue;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      dv_y = dvalue;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      dv_width = dvalue;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      dv_height = dvalue;
      break;
      case ADXMotionPaths_OFF_PATH_ROTATE:
      path_rotate = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
    IOSFloatArray *vel = [IOSFloatArray arrayWithLength:2];
    [mRelativeToController_ getCenterWithDouble:position withFloatArray:pos withFloatArray:vel];
    float rx = IOSFloatArray_Get(pos, 0);
    float ry = IOSFloatArray_Get(pos, 1);
    float radius = v_x;
    float angle = v_y;
    float dradius = dv_x;
    float dangle = dv_y;
    float drx = IOSFloatArray_Get(vel, 0);
    float dry = IOSFloatArray_Get(vel, 1);
    float pos_x = (float) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    float pos_y = (float) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
    float dpos_x = (float) (drx + dradius * JavaLangMath_sinWithDouble_(angle) + radius * JavaLangMath_cosWithDouble_(angle) * dangle);
    float dpos_y = (float) (dry - dradius * JavaLangMath_cosWithDouble_(angle) + radius * JavaLangMath_sinWithDouble_(angle) * dangle);
    dv_x = dpos_x;
    dv_y = dpos_y;
    v_x = pos_x;
    v_y = pos_y;
    if (((IOSDoubleArray *) nil_chk(slope))->size_ >= 2) {
      *IOSDoubleArray_GetRef(slope, 0) = dpos_x;
      *IOSDoubleArray_GetRef(slope, 1) = dpos_y;
    }
    if (!JavaLangFloat_isNaNWithFloat_(path_rotate)) {
      float rot = (float) (path_rotate + JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(dv_y, dv_x)));
      [((ADXMotionWidget *) nil_chk(view)) setRotationZWithFloat:rot];
    }
  }
  else {
    if (!JavaLangFloat_isNaNWithFloat_(path_rotate)) {
      float rot = 0;
      float dx = dv_x + dv_width / 2;
      float dy = dv_y + dv_height / 2;
      JrePlusAssignFloatD(&rot, path_rotate + JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(dy, dx)));
      [((ADXMotionWidget *) nil_chk(view)) setRotationZWithFloat:rot];
    }
  }
  int32_t l = JreFpToInt((0.5f + v_x));
  int32_t t = JreFpToInt((0.5f + v_y));
  int32_t r = JreFpToInt((0.5f + v_x + v_width));
  int32_t b = JreFpToInt((0.5f + v_y + v_height));
  int32_t i_width = r - l;
  int32_t i_height = b - t;
  [((ADXMotionWidget *) nil_chk(view)) layoutWithInt:l withInt:t withInt:r withInt:b];
}

- (void)getRectWithIntArray:(IOSIntArray *)toUse
            withDoubleArray:(IOSDoubleArray *)data
             withFloatArray:(IOSFloatArray *)path
                    withInt:(int32_t)offset {
  float v_x = x_;
  float v_y = y_;
  float v_width = width_;
  float v_height = height_;
  float delta_path = 0;
  float rotation = 0;
  float alpha = 0;
  float rotationX = 0;
  float rotationY = 0;
  float scaleX = 1;
  float scaleY = 1;
  float pivotX = JavaLangFloat_NaN;
  float pivotY = JavaLangFloat_NaN;
  float translationX = 0;
  float translationY = 0;
  NSString *mod;
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    float value = (float) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_POSITION:
      delta_path = value;
      break;
      case ADXMotionPaths_OFF_X:
      v_x = value;
      break;
      case ADXMotionPaths_OFF_Y:
      v_y = value;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      v_width = value;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      v_height = value;
      break;
    }
  }
  if (mRelativeToController_ != nil) {
    float rx = [mRelativeToController_ getCenterX];
    float ry = [((ADXMotion *) nil_chk(mRelativeToController_)) getCenterY];
    float radius = v_x;
    float angle = v_y;
    v_x = (float) (rx + radius * JavaLangMath_sinWithDouble_(angle) - v_width / 2);
    v_y = (float) (ry - radius * JavaLangMath_cosWithDouble_(angle) - v_height / 2);
  }
  float x1 = v_x;
  float y1 = v_y;
  float x2 = v_x + v_width;
  float y2 = y1;
  float x3 = x2;
  float y3 = v_y + v_height;
  float x4 = x1;
  float y4 = y3;
  float cx = x1 + v_width / 2;
  float cy = y1 + v_height / 2;
  if (!JavaLangFloat_isNaNWithFloat_(pivotX)) {
    cx = x1 + (x2 - x1) * pivotX;
  }
  if (!JavaLangFloat_isNaNWithFloat_(pivotY)) {
    cy = y1 + (y3 - y1) * pivotY;
  }
  if (scaleX != 1) {
    float midx = (x1 + x2) / 2;
    x1 = (x1 - midx) * scaleX + midx;
    x2 = (x2 - midx) * scaleX + midx;
    x3 = (x3 - midx) * scaleX + midx;
    x4 = (x4 - midx) * scaleX + midx;
  }
  if (scaleY != 1) {
    float midy = (y1 + y3) / 2;
    y1 = (y1 - midy) * scaleY + midy;
    y2 = (y2 - midy) * scaleY + midy;
    y3 = (y3 - midy) * scaleY + midy;
    y4 = (y4 - midy) * scaleY + midy;
  }
  if (rotation != 0) {
    float sin = (float) JavaLangMath_sinWithDouble_(JavaLangMath_toRadiansWithDouble_(rotation));
    float cos = (float) JavaLangMath_cosWithDouble_(JavaLangMath_toRadiansWithDouble_(rotation));
    float tx1 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x1, y1);
    float ty1 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x1, y1);
    float tx2 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x2, y2);
    float ty2 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x2, y2);
    float tx3 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x3, y3);
    float ty3 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x3, y3);
    float tx4 = ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x4, y4);
    float ty4 = ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(sin, cos, cx, cy, x4, y4);
    x1 = tx1;
    y1 = ty1;
    x2 = tx2;
    y2 = ty2;
    x3 = tx3;
    y3 = ty3;
    x4 = tx4;
    y4 = ty4;
  }
  JrePlusAssignFloatF(&x1, translationX);
  JrePlusAssignFloatF(&y1, translationY);
  JrePlusAssignFloatF(&x2, translationX);
  JrePlusAssignFloatF(&y2, translationY);
  JrePlusAssignFloatF(&x3, translationX);
  JrePlusAssignFloatF(&y3, translationY);
  JrePlusAssignFloatF(&x4, translationX);
  JrePlusAssignFloatF(&y4, translationY);
  *IOSFloatArray_GetRef(nil_chk(path), offset++) = x1;
  *IOSFloatArray_GetRef(path, offset++) = y1;
  *IOSFloatArray_GetRef(path, offset++) = x2;
  *IOSFloatArray_GetRef(path, offset++) = y2;
  *IOSFloatArray_GetRef(path, offset++) = x3;
  *IOSFloatArray_GetRef(path, offset++) = y3;
  *IOSFloatArray_GetRef(path, offset++) = x4;
  *IOSFloatArray_GetRef(path, offset++) = y4;
}

- (void)setDpDtWithFloat:(float)locationX
               withFloat:(float)locationY
          withFloatArray:(IOSFloatArray *)mAnchorDpDt
            withIntArray:(IOSIntArray *)toUse
         withDoubleArray:(IOSDoubleArray *)deltaData
         withDoubleArray:(IOSDoubleArray *)data {
  float d_x = 0;
  float d_y = 0;
  float d_width = 0;
  float d_height = 0;
  float deltaScaleX = 0;
  float deltaScaleY = 0;
  float mPathRotate = JavaLangFloat_NaN;
  float deltaTranslationX = 0;
  float deltaTranslationY = 0;
  NSString *mod = @" dd = ";
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    float deltaV = (float) IOSDoubleArray_Get(nil_chk(deltaData), i);
    float value = (float) IOSDoubleArray_Get(nil_chk(data), i);
    switch (IOSIntArray_Get(toUse, i)) {
      case ADXMotionPaths_OFF_POSITION:
      break;
      case ADXMotionPaths_OFF_X:
      d_x = deltaV;
      break;
      case ADXMotionPaths_OFF_Y:
      d_y = deltaV;
      break;
      case ADXMotionPaths_OFF_WIDTH:
      d_width = deltaV;
      break;
      case ADXMotionPaths_OFF_HEIGHT:
      d_height = deltaV;
      break;
    }
  }
  float deltaX = d_x - deltaScaleX * d_width / 2;
  float deltaY = d_y - deltaScaleY * d_height / 2;
  float deltaWidth = d_width * (1 + deltaScaleX);
  float deltaHeight = d_height * (1 + deltaScaleY);
  float deltaRight = deltaX + deltaWidth;
  float deltaBottom = deltaY + deltaHeight;
  *IOSFloatArray_GetRef(nil_chk(mAnchorDpDt), 0) = deltaX * (1 - locationX) + deltaRight * (locationX) + deltaTranslationX;
  *IOSFloatArray_GetRef(mAnchorDpDt, 1) = deltaY * (1 - locationY) + deltaBottom * (locationY) + deltaTranslationY;
}

- (void)fillStandardWithDoubleArray:(IOSDoubleArray *)data
                       withIntArray:(IOSIntArray *)toUse {
  IOSFloatArray *set = [IOSFloatArray arrayWithFloats:(float[]){ position_, x_, y_, width_, height_, mPathRotate_ } count:6];
  int32_t c = 0;
  for (int32_t i = 0; i < ((IOSIntArray *) nil_chk(toUse))->size_; i++) {
    if (IOSIntArray_Get(toUse, i) < set->size_) {
      *IOSDoubleArray_GetRef(nil_chk(data), c++) = IOSFloatArray_Get(set, IOSIntArray_Get(toUse, i));
    }
  }
}

- (bool)hasCustomDataWithNSString:(NSString *)name {
  return [((JavaUtilHashMap *) nil_chk(customAttributes_)) containsKeyWithId:name];
}

- (int32_t)getCustomDataCountWithNSString:(NSString *)name {
  ADXCustomVariable *a = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(customAttributes_)) getWithId:name]);
  if (a == nil) {
    return 0;
  }
  return [a numberOfInterpolatedValues];
}

- (int32_t)getCustomDataWithNSString:(NSString *)name
                     withDoubleArray:(IOSDoubleArray *)value
                             withInt:(int32_t)offset {
  ADXCustomVariable *a = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(customAttributes_)) getWithId:name]);
  if (a == nil) {
    return 0;
  }
  else if ([a numberOfInterpolatedValues] == 1) {
    *IOSDoubleArray_GetRef(nil_chk(value), offset) = [a getValueToInterpolate];
    return 1;
  }
  else {
    int32_t N = [a numberOfInterpolatedValues];
    IOSFloatArray *f = [IOSFloatArray arrayWithLength:N];
    [a getValuesToInterpolateWithFloatArray:f];
    for (int32_t i = 0; i < N; i++) {
      *IOSDoubleArray_GetRef(nil_chk(value), offset++) = IOSFloatArray_Get(f, i);
    }
    return N;
  }
}

- (void)setBoundsWithFloat:(float)x
                 withFloat:(float)y
                 withFloat:(float)w
                 withFloat:(float)h {
  self->x_ = x;
  self->y_ = y;
  width_ = w;
  height_ = h;
}

- (int32_t)compareToWithId:(ADXMotionPaths *)o {
  cast_chk(o, [ADXMotionPaths class]);
  return JavaLangFloat_compareWithFloat_withFloat_(position_, ((ADXMotionPaths *) nil_chk(o))->position_);
}

- (void)applyParametersWithADXMotionWidget:(ADXMotionWidget *)c {
  ADXMotionPaths *point = self;
  JreStrongAssign(&point->mKeyFrameEasing_, ADXEasing_getInterpolatorWithNSString_(((ADXMotionWidget_Motion *) nil_chk(((ADXMotionWidget *) nil_chk(c))->motion_))->mTransitionEasing_));
  point->mPathMotionArc_ = ((ADXMotionWidget_Motion *) nil_chk(c->motion_))->mPathMotionArc_;
  point->mAnimateRelativeTo_ = c->motion_->mAnimateRelativeTo_;
  point->mPathRotate_ = c->motion_->mPathRotate_;
  point->mDrawPath_ = c->motion_->mDrawPath_;
  point->mAnimateCircleAngleTo_ = c->motion_->mAnimateCircleAngleTo_;
  point->mProgress_ = ((ADXMotionWidget_PropertySet *) nil_chk(c->propertySet_))->mProgress_;
  point->mRelativeAngle_ = 0;
  id<JavaUtilSet> at = JreRetainedLocalValue([c getCustomAttributeNames]);
  for (NSString * __strong s in nil_chk(at)) {
    ADXCustomVariable *attr = JreRetainedLocalValue([c getCustomAttributeWithNSString:s]);
    if (attr != nil && [attr isContinuous]) {
      [((JavaUtilHashMap *) nil_chk(self->customAttributes_)) putWithId:s withId:attr];
    }
  }
}

- (void)configureRelativeToWithADXMotion:(ADXMotion *)toOrbit {
  IOSDoubleArray *p = [((ADXMotion *) nil_chk(toOrbit)) getPosWithDouble:mProgress_];
}

- (void)dealloc {
  RELEASE_(mKeyFrameEasing_);
  RELEASE_(mRelativeToController_);
  RELEASE_(customAttributes_);
  RELEASE_(mTempValue_);
  RELEASE_(mTempDelta_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 3, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 6, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 7, 1, -1, -1, -1, -1 },
    { NULL, "F", 0x1a, 8, 9, -1, -1, -1, -1 },
    { NULL, "F", 0x1a, 10, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 15, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 15, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 18, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 19, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 23, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 24, 25, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 26, 27, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 28, 29, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 30, 29, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 31, 32, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 33, 34, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 35, 36, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 37, 38, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 39, 40, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initCartesianWithADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[2].selector = @selector(initWithInt:withInt:withADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[3].selector = @selector(initPolarWithInt:withInt:withADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[4].selector = @selector(setupRelativeWithADXMotion:withADXMotionPaths:);
  methods[5].selector = @selector(initScreenWithInt:withInt:withADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[6].selector = @selector(initPathWithADXMotionKeyPosition:withADXMotionPaths:withADXMotionPaths:);
  methods[7].selector = @selector(xRotateWithFloat:withFloat:withFloat:withFloat:withFloat:withFloat:);
  methods[8].selector = @selector(yRotateWithFloat:withFloat:withFloat:withFloat:withFloat:withFloat:);
  methods[9].selector = @selector(diffWithFloat:withFloat:);
  methods[10].selector = @selector(differentWithADXMotionPaths:withBooleanArray:withNSStringArray:withBoolean:);
  methods[11].selector = @selector(getCenterWithDouble:withIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[12].selector = @selector(getCenterWithDouble:withIntArray:withDoubleArray:withFloatArray:withDoubleArray:withFloatArray:);
  methods[13].selector = @selector(getCenterVelocityWithDouble:withIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[14].selector = @selector(getBoundsWithIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[15].selector = @selector(setViewWithFloat:withADXMotionWidget:withIntArray:withDoubleArray:withDoubleArray:withDoubleArray:);
  methods[16].selector = @selector(getRectWithIntArray:withDoubleArray:withFloatArray:withInt:);
  methods[17].selector = @selector(setDpDtWithFloat:withFloat:withFloatArray:withIntArray:withDoubleArray:withDoubleArray:);
  methods[18].selector = @selector(fillStandardWithDoubleArray:withIntArray:);
  methods[19].selector = @selector(hasCustomDataWithNSString:);
  methods[20].selector = @selector(getCustomDataCountWithNSString:);
  methods[21].selector = @selector(getCustomDataWithNSString:withDoubleArray:withInt:);
  methods[22].selector = @selector(setBoundsWithFloat:withFloat:withFloat:withFloat:);
  methods[23].selector = @selector(compareToWithId:);
  methods[24].selector = @selector(applyParametersWithADXMotionWidget:);
  methods[25].selector = @selector(configureRelativeToWithADXMotion:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 41, -1, -1 },
    { "DEBUG", "Z", .constantValue.asBOOL = ADXMotionPaths_DEBUG, 0x19, -1, -1, -1, -1 },
    { "OLD_WAY", "Z", .constantValue.asBOOL = ADXMotionPaths_OLD_WAY, 0x19, -1, -1, -1, -1 },
    { "OFF_POSITION", "I", .constantValue.asInt = ADXMotionPaths_OFF_POSITION, 0x18, -1, -1, -1, -1 },
    { "OFF_X", "I", .constantValue.asInt = ADXMotionPaths_OFF_X, 0x18, -1, -1, -1, -1 },
    { "OFF_Y", "I", .constantValue.asInt = ADXMotionPaths_OFF_Y, 0x18, -1, -1, -1, -1 },
    { "OFF_WIDTH", "I", .constantValue.asInt = ADXMotionPaths_OFF_WIDTH, 0x18, -1, -1, -1, -1 },
    { "OFF_HEIGHT", "I", .constantValue.asInt = ADXMotionPaths_OFF_HEIGHT, 0x18, -1, -1, -1, -1 },
    { "OFF_PATH_ROTATE", "I", .constantValue.asInt = ADXMotionPaths_OFF_PATH_ROTATE, 0x18, -1, -1, -1, -1 },
    { "PERPENDICULAR", "I", .constantValue.asInt = ADXMotionPaths_PERPENDICULAR, 0x19, -1, -1, -1, -1 },
    { "CARTESIAN", "I", .constantValue.asInt = ADXMotionPaths_CARTESIAN, 0x19, -1, -1, -1, -1 },
    { "SCREEN", "I", .constantValue.asInt = ADXMotionPaths_SCREEN, 0x19, -1, -1, -1, -1 },
    { "names", "[LNSString;", .constantValue.asLong = 0, 0x8, -1, 42, -1, -1 },
    { "mKeyFrameEasing_", "LADXEasing;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mDrawPath_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "time_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "position_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "x_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "y_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "width_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "height_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPathRotate_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mProgress_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPathMotionArc_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnimateRelativeTo_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mRelativeAngle_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mRelativeToController_", "LADXMotion;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "customAttributes_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x0, -1, -1, 43, -1 },
    { "mMode_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnimateCircleAngleTo_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTempValue_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTempDelta_", "[D", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "initCartesian", "LADXMotionKeyPosition;LADXMotionPaths;LADXMotionPaths;", "IILADXMotionKeyPosition;LADXMotionPaths;LADXMotionPaths;", "initPolar", "setupRelative", "LADXMotion;LADXMotionPaths;", "initScreen", "initPath", "xRotate", "FFFFFF", "yRotate", "diff", "FF", "different", "LADXMotionPaths;[Z[LNSString;Z", "getCenter", "D[I[D[FI", "D[I[D[F[D[F", "getCenterVelocity", "getBounds", "[I[D[FI", "setView", "FLADXMotionWidget;[I[D[D[D", "getRect", "setDpDt", "FF[F[I[D[D", "fillStandard", "[D[I", "hasCustomData", "LNSString;", "getCustomDataCount", "getCustomData", "LNSString;[DI", "setBounds", "FFFF", "compareTo", "LADXMotionPaths;", "applyParameters", "LADXMotionWidget;", "configureRelativeTo", "LADXMotion;", &ADXMotionPaths_TAG, &ADXMotionPaths_names, "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/core/motion/CustomVariable;>;", "Ljava/lang/Object;Ljava/lang/Comparable<Landroidx/constraintlayout/core/motion/MotionPaths;>;" };
  static const J2ObjcClassInfo _ADXMotionPaths = { "MotionPaths", "androidx.constraintlayout.core.motion", ptrTable, methods, fields, 7, 0x1, 26, 32, -1, -1, -1, 44, -1 };
  return &_ADXMotionPaths;
}

+ (void)initialize {
  if (self == [ADXMotionPaths class]) {
    JreStrongAssignAndConsume(&ADXMotionPaths_names, [IOSObjectArray newArrayWithObjects:(id[]){ @"position", @"x", @"y", @"width", @"height", @"pathRotate" } count:6 type:NSString_class_()]);
    J2OBJC_SET_INITIALIZED(ADXMotionPaths)
  }
}

@end

void ADXMotionPaths_init(ADXMotionPaths *self) {
  NSObject_init(self);
  self->mDrawPath_ = 0;
  self->mPathRotate_ = JavaLangFloat_NaN;
  self->mProgress_ = JavaLangFloat_NaN;
  self->mPathMotionArc_ = ADXMotionWidget_UNSET;
  self->mAnimateRelativeTo_ = ADXMotionWidget_UNSET;
  self->mRelativeAngle_ = JavaLangFloat_NaN;
  JreStrongAssign(&self->mRelativeToController_, nil);
  JreStrongAssignAndConsume(&self->customAttributes_, new_JavaUtilHashMap_init());
  self->mMode_ = 0;
  JreStrongAssignAndConsume(&self->mTempValue_, [IOSDoubleArray newArrayWithLength:18]);
  JreStrongAssignAndConsume(&self->mTempDelta_, [IOSDoubleArray newArrayWithLength:18]);
}

ADXMotionPaths *new_ADXMotionPaths_init() {
  J2OBJC_NEW_IMPL(ADXMotionPaths, init)
}

ADXMotionPaths *create_ADXMotionPaths_init() {
  J2OBJC_CREATE_IMPL(ADXMotionPaths, init)
}

void ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(ADXMotionPaths *self, int32_t parentWidth, int32_t parentHeight, ADXMotionKeyPosition *c, ADXMotionPaths *startTimePoint, ADXMotionPaths *endTimePoint) {
  NSObject_init(self);
  self->mDrawPath_ = 0;
  self->mPathRotate_ = JavaLangFloat_NaN;
  self->mProgress_ = JavaLangFloat_NaN;
  self->mPathMotionArc_ = ADXMotionWidget_UNSET;
  self->mAnimateRelativeTo_ = ADXMotionWidget_UNSET;
  self->mRelativeAngle_ = JavaLangFloat_NaN;
  JreStrongAssign(&self->mRelativeToController_, nil);
  JreStrongAssignAndConsume(&self->customAttributes_, new_JavaUtilHashMap_init());
  self->mMode_ = 0;
  JreStrongAssignAndConsume(&self->mTempValue_, [IOSDoubleArray newArrayWithLength:18]);
  JreStrongAssignAndConsume(&self->mTempDelta_, [IOSDoubleArray newArrayWithLength:18]);
  if (((ADXMotionPaths *) nil_chk(startTimePoint))->mAnimateRelativeTo_ != ADXMotionWidget_UNSET) {
    [self initPolarWithInt:parentWidth withInt:parentHeight withADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
  }
  switch (((ADXMotionKeyPosition *) nil_chk(c))->mPositionType_) {
    case ADXMotionKeyPosition_TYPE_SCREEN:
    [self initScreenWithInt:parentWidth withInt:parentHeight withADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
    case ADXMotionKeyPosition_TYPE_PATH:
    [self initPathWithADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
    default:
    case ADXMotionKeyPosition_TYPE_CARTESIAN:
    [self initCartesianWithADXMotionKeyPosition:c withADXMotionPaths:startTimePoint withADXMotionPaths:endTimePoint];
    return;
  }
}

ADXMotionPaths *new_ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(int32_t parentWidth, int32_t parentHeight, ADXMotionKeyPosition *c, ADXMotionPaths *startTimePoint, ADXMotionPaths *endTimePoint) {
  J2OBJC_NEW_IMPL(ADXMotionPaths, initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_, parentWidth, parentHeight, c, startTimePoint, endTimePoint)
}

ADXMotionPaths *create_ADXMotionPaths_initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_(int32_t parentWidth, int32_t parentHeight, ADXMotionKeyPosition *c, ADXMotionPaths *startTimePoint, ADXMotionPaths *endTimePoint) {
  J2OBJC_CREATE_IMPL(ADXMotionPaths, initWithInt_withInt_withADXMotionKeyPosition_withADXMotionPaths_withADXMotionPaths_, parentWidth, parentHeight, c, startTimePoint, endTimePoint)
}

float ADXMotionPaths_xRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(float sin, float cos, float cx, float cy, float x, float y) {
  ADXMotionPaths_initialize();
  x = x - cx;
  y = y - cy;
  return x * cos - y * sin + cx;
}

float ADXMotionPaths_yRotateWithFloat_withFloat_withFloat_withFloat_withFloat_withFloat_(float sin, float cos, float cx, float cy, float x, float y) {
  ADXMotionPaths_initialize();
  x = x - cx;
  y = y - cy;
  return x * sin + y * cos + cy;
}

bool ADXMotionPaths_diffWithFloat_withFloat_(ADXMotionPaths *self, float a, float b) {
  if (JavaLangFloat_isNaNWithFloat_(a) || JavaLangFloat_isNaNWithFloat_(b)) {
    return JavaLangFloat_isNaNWithFloat_(a) != JavaLangFloat_isNaNWithFloat_(b);
  }
  return JavaLangMath_absWithFloat_(a - b) > 0.000001f;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXMotionPaths)

J2OBJC_NAME_MAPPING(ADXMotionPaths, "androidx.constraintlayout.core.motion", "ADX")
