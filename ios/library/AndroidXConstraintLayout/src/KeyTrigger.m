//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\motion\widget\KeyTrigger.java
//

#define J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION 1




#include "AttributeSet.h"
#include "CLDebug.h"
#include "ConstraintAttribute.h"
#include "Context.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "Key.h"
#include "KeyTrigger.h"
#include "Log.h"
#include "MotionLayout.h"
#include "RectF.h"
#include "View.h"
#include "ViewGroup.h"
#include "ViewParent.h"
#include "java/lang/Boolean.h"
#include "java/lang/Character.h"
#include "java/lang/Exception.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/NoSuchMethodException.h"
#include "java/lang/reflect/Method.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Locale.h"
#include "java/util/Set.h"


@class NSString;


#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic ignored "-Wswitch"


@interface ADXKeyTrigger () {
 @public
  int32_t mCurveFit_;
  NSString *mCross_;
  int32_t mTriggerReceiver_;
  NSString *mNegativeCross_;
  NSString *mPositiveCross_;
  int32_t mTriggerID_;
  int32_t mTriggerCollisionId_;
  ADView *mTriggerCollisionView_;
  bool mFireCrossReset_;
  bool mFireNegativeReset_;
  bool mFirePositiveReset_;
  float mFireLastPos_;
  bool mPostLayout_;
}

- (void)setUpRectWithADRectF:(ADRectF *)rect
                  withADView:(ADView *)child
                 withBoolean:(bool)postLayout;

- (void)fireWithNSString:(NSString *)str
              withADView:(ADView *)call;

- (void)fireCustomWithNSString:(NSString *)str
                    withADView:(ADView *)view;

@end

J2OBJC_FIELD_SETTER(ADXKeyTrigger, mCross_, NSString *)
J2OBJC_FIELD_SETTER(ADXKeyTrigger, mNegativeCross_, NSString *)
J2OBJC_FIELD_SETTER(ADXKeyTrigger, mPositiveCross_, NSString *)
J2OBJC_FIELD_SETTER(ADXKeyTrigger, mTriggerCollisionView_, ADView *)

inline NSString *ADXKeyTrigger_get_TAG(void);
static NSString *ADXKeyTrigger_TAG = @"KeyTrigger";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXKeyTrigger, TAG, NSString *)

__attribute__((unused)) static void ADXKeyTrigger_setUpRectWithADRectF_withADView_withBoolean_(ADXKeyTrigger *self, ADRectF *rect, ADView *child, bool postLayout);

__attribute__((unused)) static void ADXKeyTrigger_fireWithNSString_withADView_(ADXKeyTrigger *self, NSString *str, ADView *call);

__attribute__((unused)) static void ADXKeyTrigger_fireCustomWithNSString_withADView_(ADXKeyTrigger *self, NSString *str, ADView *view);

@interface ADXKeyTrigger_Loader : NSObject

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXKeyTrigger_Loader)

__attribute__((unused)) static void ADXKeyTrigger_Loader_init(ADXKeyTrigger_Loader *self);

__attribute__((unused)) static ADXKeyTrigger_Loader *new_ADXKeyTrigger_Loader_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADXKeyTrigger_Loader *create_ADXKeyTrigger_Loader_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ADXKeyTrigger_Loader)


NSString *ADXKeyTrigger_NAME = @"KeyTrigger";
NSString *ADXKeyTrigger_VIEW_TRANSITION_ON_CROSS = @"viewTransitionOnCross";
NSString *ADXKeyTrigger_VIEW_TRANSITION_ON_POSITIVE_CROSS = @"viewTransitionOnPositiveCross";
NSString *ADXKeyTrigger_VIEW_TRANSITION_ON_NEGATIVE_CROSS = @"viewTransitionOnNegativeCross";
NSString *ADXKeyTrigger_POST_LAYOUT = @"postLayout";
NSString *ADXKeyTrigger_TRIGGER_SLACK = @"triggerSlack";
NSString *ADXKeyTrigger_TRIGGER_COLLISION_VIEW = @"triggerCollisionView";
NSString *ADXKeyTrigger_TRIGGER_COLLISION_ID = @"triggerCollisionId";
NSString *ADXKeyTrigger_TRIGGER_ID = @"triggerID";
NSString *ADXKeyTrigger_POSITIVE_CROSS = @"positiveCross";
NSString *ADXKeyTrigger_NEGATIVE_CROSS = @"negativeCross";
NSString *ADXKeyTrigger_TRIGGER_RECEIVER = @"triggerReceiver";
NSString *ADXKeyTrigger_CROSS = @"CROSS";

@implementation ADXKeyTrigger

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXKeyTrigger_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)load__WithADContext:(ADContext *)context
         withADAttributeSet:(ADAttributeSet *)attrs {
}

- (int32_t)getCurveFit {
  return mCurveFit_;
}

- (void)getAttributeNamesWithJavaUtilHashSet:(JavaUtilHashSet *)attributes {
}

- (void)addValuesWithJavaUtilHashMap:(JavaUtilHashMap *)splines {
}

- (void)setValueWithNSString:(NSString *)tag
                      withId:(id)value {
  switch (JreIndexOfStr(tag, (id[]){ ADXKeyTrigger_CROSS, ADXKeyTrigger_TRIGGER_RECEIVER, ADXKeyTrigger_NEGATIVE_CROSS, ADXKeyTrigger_POSITIVE_CROSS, ADXKeyTrigger_TRIGGER_ID, ADXKeyTrigger_TRIGGER_COLLISION_ID, ADXKeyTrigger_TRIGGER_COLLISION_VIEW, ADXKeyTrigger_TRIGGER_SLACK, ADXKeyTrigger_POST_LAYOUT, ADXKeyTrigger_VIEW_TRANSITION_ON_NEGATIVE_CROSS, ADXKeyTrigger_VIEW_TRANSITION_ON_POSITIVE_CROSS, ADXKeyTrigger_VIEW_TRANSITION_ON_CROSS }, 12)) {
    case 0:
    JreStrongAssign(&mCross_, [nil_chk(value) description]);
    break;
    case 1:
    mTriggerReceiver_ = [self toIntWithId:value];
    break;
    case 2:
    JreStrongAssign(&mNegativeCross_, [nil_chk(value) description]);
    break;
    case 3:
    JreStrongAssign(&mPositiveCross_, [nil_chk(value) description]);
    break;
    case 4:
    mTriggerID_ = [self toIntWithId:value];
    break;
    case 5:
    mTriggerCollisionId_ = [self toIntWithId:value];
    break;
    case 6:
    JreStrongAssign(&mTriggerCollisionView_, (ADView *) cast_chk(value, [ADView class]));
    break;
    case 7:
    mTriggerSlack_ = [self toFloatWithId:value];
    break;
    case 8:
    mPostLayout_ = [self toBooleanWithId:value];
    break;
    case 9:
    mViewTransitionOnNegativeCross_ = [self toIntWithId:value];
    break;
    case 10:
    mViewTransitionOnPositiveCross_ = [self toIntWithId:value];
    break;
    case 11:
    mViewTransitionOnCross_ = [self toIntWithId:value];
    break;
  }
}

- (void)setUpRectWithADRectF:(ADRectF *)rect
                  withADView:(ADView *)child
                 withBoolean:(bool)postLayout {
  ADXKeyTrigger_setUpRectWithADRectF_withADView_withBoolean_(self, rect, child, postLayout);
}

- (void)conditionallyFireWithFloat:(float)pos
                        withADView:(ADView *)child {
  bool fireCross = false;
  bool fireNegative = false;
  bool firePositive = false;
  if (mTriggerCollisionId_ != JreLoadStatic(ADXKey, UNSET)) {
    if (mTriggerCollisionView_ == nil) {
      JreStrongAssign(&mTriggerCollisionView_, [((ADViewGroup *) nil_chk(((ADViewGroup *) cast_chk([((ADView *) nil_chk(child)) getParent], [ADViewGroup class])))) findViewByIdWithInt:mTriggerCollisionId_]);
    }
    ADXKeyTrigger_setUpRectWithADRectF_withADView_withBoolean_(self, mCollisionRect_, mTriggerCollisionView_, mPostLayout_);
    ADXKeyTrigger_setUpRectWithADRectF_withADView_withBoolean_(self, mTargetRect_, child, mPostLayout_);
    bool in = [((ADRectF *) nil_chk(mCollisionRect_)) intersectWithADRectF:mTargetRect_];
    if (in) {
      if (mFireCrossReset_) {
        fireCross = true;
        mFireCrossReset_ = false;
      }
      if (mFirePositiveReset_) {
        firePositive = true;
        mFirePositiveReset_ = false;
      }
      mFireNegativeReset_ = true;
    }
    else {
      if (!mFireCrossReset_) {
        fireCross = true;
        mFireCrossReset_ = true;
      }
      if (mFireNegativeReset_) {
        fireNegative = true;
        mFireNegativeReset_ = false;
      }
      mFirePositiveReset_ = true;
    }
  }
  else {
    if (mFireCrossReset_) {
      float offset = pos - mFireThreshold_;
      float lastOffset = mFireLastPos_ - mFireThreshold_;
      if (offset * lastOffset < 0) {
        fireCross = true;
        mFireCrossReset_ = false;
      }
    }
    else {
      if (JavaLangMath_absWithFloat_(pos - mFireThreshold_) > mTriggerSlack_) {
        mFireCrossReset_ = true;
      }
    }
    if (mFireNegativeReset_) {
      float offset = pos - mFireThreshold_;
      float lastOffset = mFireLastPos_ - mFireThreshold_;
      if (offset * lastOffset < 0 && offset < 0) {
        fireNegative = true;
        mFireNegativeReset_ = false;
      }
    }
    else {
      if (JavaLangMath_absWithFloat_(pos - mFireThreshold_) > mTriggerSlack_) {
        mFireNegativeReset_ = true;
      }
    }
    if (mFirePositiveReset_) {
      float offset = pos - mFireThreshold_;
      float lastOffset = mFireLastPos_ - mFireThreshold_;
      if (offset * lastOffset < 0 && offset > 0) {
        firePositive = true;
        mFirePositiveReset_ = false;
      }
    }
    else {
      if (JavaLangMath_absWithFloat_(pos - mFireThreshold_) > mTriggerSlack_) {
        mFirePositiveReset_ = true;
      }
    }
  }
  mFireLastPos_ = pos;
  if (fireNegative || fireCross || firePositive) {
    [((ADXMotionLayout *) nil_chk(((ADXMotionLayout *) cast_chk([((ADView *) nil_chk(child)) getParent], [ADXMotionLayout class])))) fireTriggerWithInt:mTriggerID_ withBoolean:firePositive withFloat:pos];
  }
  ADView *call = (mTriggerReceiver_ == JreLoadStatic(ADXKey, UNSET)) ? child : [((ADXMotionLayout *) nil_chk(((ADXMotionLayout *) cast_chk([((ADView *) nil_chk(child)) getParent], [ADXMotionLayout class])))) findViewByIdWithInt:mTriggerReceiver_];
  if (fireNegative) {
    if (mNegativeCross_ != nil) {
      ADXKeyTrigger_fireWithNSString_withADView_(self, mNegativeCross_, call);
    }
    if (mViewTransitionOnNegativeCross_ != JreLoadStatic(ADXKey, UNSET)) {
      [((ADXMotionLayout *) nil_chk(((ADXMotionLayout *) cast_chk([((ADView *) nil_chk(child)) getParent], [ADXMotionLayout class])))) viewTransitionWithInt:mViewTransitionOnNegativeCross_ withADViewArray:[IOSObjectArray arrayWithObjects:(id[]){ call } count:1 type:ADView_class_()]];
    }
  }
  if (firePositive) {
    if (mPositiveCross_ != nil) {
      ADXKeyTrigger_fireWithNSString_withADView_(self, mPositiveCross_, call);
    }
    if (mViewTransitionOnPositiveCross_ != JreLoadStatic(ADXKey, UNSET)) {
      [((ADXMotionLayout *) nil_chk(((ADXMotionLayout *) cast_chk([((ADView *) nil_chk(child)) getParent], [ADXMotionLayout class])))) viewTransitionWithInt:mViewTransitionOnPositiveCross_ withADViewArray:[IOSObjectArray arrayWithObjects:(id[]){ call } count:1 type:ADView_class_()]];
    }
  }
  if (fireCross) {
    if (mCross_ != nil) {
      ADXKeyTrigger_fireWithNSString_withADView_(self, mCross_, call);
    }
    if (mViewTransitionOnCross_ != JreLoadStatic(ADXKey, UNSET)) {
      [((ADXMotionLayout *) nil_chk(((ADXMotionLayout *) cast_chk([((ADView *) nil_chk(child)) getParent], [ADXMotionLayout class])))) viewTransitionWithInt:mViewTransitionOnCross_ withADViewArray:[IOSObjectArray arrayWithObjects:(id[]){ call } count:1 type:ADView_class_()]];
    }
  }
}

- (void)fireWithNSString:(NSString *)str
              withADView:(ADView *)call {
  ADXKeyTrigger_fireWithNSString_withADView_(self, str, call);
}

- (void)fireCustomWithNSString:(NSString *)str
                    withADView:(ADView *)view {
  ADXKeyTrigger_fireCustomWithNSString_withADView_(self, str, view);
}

- (ADXKey *)copy__WithADXKey:(ADXKey *)src {
  [super copy__WithADXKey:src];
  ADXKeyTrigger *k = (ADXKeyTrigger *) cast_chk(src, [ADXKeyTrigger class]);
  mCurveFit_ = ((ADXKeyTrigger *) nil_chk(k))->mCurveFit_;
  JreStrongAssign(&mCross_, k->mCross_);
  mTriggerReceiver_ = k->mTriggerReceiver_;
  JreStrongAssign(&mNegativeCross_, k->mNegativeCross_);
  JreStrongAssign(&mPositiveCross_, k->mPositiveCross_);
  mTriggerID_ = k->mTriggerID_;
  mTriggerCollisionId_ = k->mTriggerCollisionId_;
  JreStrongAssign(&mTriggerCollisionView_, k->mTriggerCollisionView_);
  mTriggerSlack_ = k->mTriggerSlack_;
  mFireCrossReset_ = k->mFireCrossReset_;
  mFireNegativeReset_ = k->mFireNegativeReset_;
  mFirePositiveReset_ = k->mFirePositiveReset_;
  mFireThreshold_ = k->mFireThreshold_;
  mFireLastPos_ = k->mFireLastPos_;
  mPostLayout_ = k->mPostLayout_;
  JreStrongAssign(&mCollisionRect_, k->mCollisionRect_);
  JreStrongAssign(&mTargetRect_, k->mTargetRect_);
  JreStrongAssign(&mMethodHashMap_, k->mMethodHashMap_);
  return self;
}

- (ADXKey *)java_clone {
  return [create_ADXKeyTrigger_init() copy__WithADXKey:self];
}

- (void)dealloc {
  RELEASE_(mCross_);
  RELEASE_(mNegativeCross_);
  RELEASE_(mPositiveCross_);
  RELEASE_(mTriggerCollisionView_);
  RELEASE_(mCollisionRect_);
  RELEASE_(mTargetRect_);
  RELEASE_(mMethodHashMap_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
    { NULL, "V", 0x1, 5, 6, -1, 7, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 12, 13, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 14, 15, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 16, 15, -1, -1, -1, -1 },
    { NULL, "LADXKey;", 0x1, 17, 18, -1, -1, -1, -1 },
    { NULL, "LADXKey;", 0x1, 19, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(load__WithADContext:withADAttributeSet:);
  methods[2].selector = @selector(getCurveFit);
  methods[3].selector = @selector(getAttributeNamesWithJavaUtilHashSet:);
  methods[4].selector = @selector(addValuesWithJavaUtilHashMap:);
  methods[5].selector = @selector(setValueWithNSString:withId:);
  methods[6].selector = @selector(setUpRectWithADRectF:withADView:withBoolean:);
  methods[7].selector = @selector(conditionallyFireWithFloat:withADView:);
  methods[8].selector = @selector(fireWithNSString:withADView:);
  methods[9].selector = @selector(fireCustomWithNSString:withADView:);
  methods[10].selector = @selector(copy__WithADXKey:);
  methods[11].selector = @selector(java_clone);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NAME", "LNSString;", .constantValue.asLong = 0, 0x18, -1, 20, -1, -1 },
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 21, -1, -1 },
    { "VIEW_TRANSITION_ON_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 22, -1, -1 },
    { "VIEW_TRANSITION_ON_POSITIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 23, -1, -1 },
    { "VIEW_TRANSITION_ON_NEGATIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 24, -1, -1 },
    { "POST_LAYOUT", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 25, -1, -1 },
    { "TRIGGER_SLACK", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 26, -1, -1 },
    { "TRIGGER_COLLISION_VIEW", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 27, -1, -1 },
    { "TRIGGER_COLLISION_ID", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 28, -1, -1 },
    { "TRIGGER_ID", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 29, -1, -1 },
    { "POSITIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 30, -1, -1 },
    { "NEGATIVE_CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 31, -1, -1 },
    { "TRIGGER_RECEIVER", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 32, -1, -1 },
    { "CROSS", "LNSString;", .constantValue.asLong = 0, 0x19, -1, 33, -1, -1 },
    { "mCurveFit_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mCross_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerReceiver_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mNegativeCross_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPositiveCross_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerID_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerCollisionId_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerCollisionView_", "LADView;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTriggerSlack_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mFireCrossReset_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFireNegativeReset_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFirePositiveReset_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFireThreshold_", "F", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mFireLastPos_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPostLayout_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mViewTransitionOnNegativeCross_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mViewTransitionOnPositiveCross_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mViewTransitionOnCross_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCollisionRect_", "LADRectF;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTargetRect_", "LADRectF;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mMethodHashMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x0, -1, -1, 34, -1 },
    { "KEY_TYPE", "I", .constantValue.asInt = ADXKeyTrigger_KEY_TYPE, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "load", "LADContext;LADAttributeSet;", "getAttributeNames", "LJavaUtilHashSet;", "(Ljava/util/HashSet<Ljava/lang/String;>;)V", "addValues", "LJavaUtilHashMap;", "(Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/motion/utils/ViewSpline;>;)V", "setValue", "LNSString;LNSObject;", "setUpRect", "LADRectF;LADView;Z", "conditionallyFire", "FLADView;", "fire", "LNSString;LADView;", "fireCustom", "copy", "LADXKey;", "clone", &ADXKeyTrigger_NAME, &ADXKeyTrigger_TAG, &ADXKeyTrigger_VIEW_TRANSITION_ON_CROSS, &ADXKeyTrigger_VIEW_TRANSITION_ON_POSITIVE_CROSS, &ADXKeyTrigger_VIEW_TRANSITION_ON_NEGATIVE_CROSS, &ADXKeyTrigger_POST_LAYOUT, &ADXKeyTrigger_TRIGGER_SLACK, &ADXKeyTrigger_TRIGGER_COLLISION_VIEW, &ADXKeyTrigger_TRIGGER_COLLISION_ID, &ADXKeyTrigger_TRIGGER_ID, &ADXKeyTrigger_POSITIVE_CROSS, &ADXKeyTrigger_NEGATIVE_CROSS, &ADXKeyTrigger_TRIGGER_RECEIVER, &ADXKeyTrigger_CROSS, "Ljava/util/HashMap<Ljava/lang/String;Ljava/lang/reflect/Method;>;", "LADXKeyTrigger_Loader;" };
  static const J2ObjcClassInfo _ADXKeyTrigger = { "KeyTrigger", "androidx.constraintlayout.motion.widget", ptrTable, methods, fields, 7, 0x1, 12, 36, -1, 35, -1, -1, -1 };
  return &_ADXKeyTrigger;
}

@end

void ADXKeyTrigger_init(ADXKeyTrigger *self) {
  ADXKey_init(self);
  self->mCurveFit_ = -1;
  JreStrongAssign(&self->mCross_, nil);
  self->mTriggerReceiver_ = JreLoadStatic(ADXKey, UNSET);
  JreStrongAssign(&self->mNegativeCross_, nil);
  JreStrongAssign(&self->mPositiveCross_, nil);
  self->mTriggerID_ = JreLoadStatic(ADXKey, UNSET);
  self->mTriggerCollisionId_ = JreLoadStatic(ADXKey, UNSET);
  JreStrongAssign(&self->mTriggerCollisionView_, nil);
  self->mTriggerSlack_ = .1f;
  self->mFireCrossReset_ = true;
  self->mFireNegativeReset_ = true;
  self->mFirePositiveReset_ = true;
  self->mFireThreshold_ = JavaLangFloat_NaN;
  self->mPostLayout_ = false;
  self->mViewTransitionOnNegativeCross_ = JreLoadStatic(ADXKey, UNSET);
  self->mViewTransitionOnPositiveCross_ = JreLoadStatic(ADXKey, UNSET);
  self->mViewTransitionOnCross_ = JreLoadStatic(ADXKey, UNSET);
  JreStrongAssignAndConsume(&self->mCollisionRect_, new_ADRectF_init());
  JreStrongAssignAndConsume(&self->mTargetRect_, new_ADRectF_init());
  JreStrongAssignAndConsume(&self->mMethodHashMap_, new_JavaUtilHashMap_init());
  {
    self->mType_ = ADXKeyTrigger_KEY_TYPE;
    JreStrongAssignAndConsume(&self->mCustomConstraints_, new_JavaUtilHashMap_init());
  }
}

ADXKeyTrigger *new_ADXKeyTrigger_init() {
  J2OBJC_NEW_IMPL(ADXKeyTrigger, init)
}

ADXKeyTrigger *create_ADXKeyTrigger_init() {
  J2OBJC_CREATE_IMPL(ADXKeyTrigger, init)
}

void ADXKeyTrigger_setUpRectWithADRectF_withADView_withBoolean_(ADXKeyTrigger *self, ADRectF *rect, ADView *child, bool postLayout) {
  ((ADRectF *) nil_chk(rect))->top_ = [((ADView *) nil_chk(child)) getTop];
  rect->bottom_ = [child getBottom];
  rect->left_ = [child getLeft];
  rect->right_ = [child getRight];
  if (postLayout) {
  }
}

void ADXKeyTrigger_fireWithNSString_withADView_(ADXKeyTrigger *self, NSString *str, ADView *call) {
  if (str == nil) {
    return;
  }
  if (![str java_hasPrefix:@"."]) {
    switch (JreIndexOfStr(str, (id[]){ @"state0", @"state1", @"state2", @"state3", @"state4", @"stateYes", @"stateNo" }, 7)) {
      case 0:
      [((ADView *) nil_chk(call)) state0];
      break;
      case 1:
      [((ADView *) nil_chk(call)) state1];
      break;
      case 2:
      [((ADView *) nil_chk(call)) state2];
      break;
      case 3:
      [((ADView *) nil_chk(call)) state3];
      break;
      case 4:
      [((ADView *) nil_chk(call)) state4];
      break;
      case 5:
      [((ADView *) nil_chk(call)) stateYes];
      break;
      case 6:
      [((ADView *) nil_chk(call)) stateNo];
      break;
      default:
      break;
    }
    return;
  }
  if ([str java_hasPrefix:@"."]) {
    ADXKeyTrigger_fireCustomWithNSString_withADView_(self, str, call);
    return;
  }
  JavaLangReflectMethod *method = nil;
  if ([((JavaUtilHashMap *) nil_chk(self->mMethodHashMap_)) containsKeyWithId:str]) {
    method = [((JavaUtilHashMap *) nil_chk(self->mMethodHashMap_)) getWithId:str];
    if (method == nil) {
      return;
    }
  }
  if (method == nil) {
    @try {
      method = [[((ADView *) nil_chk(call)) java_getClass] getMethod:str parameterTypes:[IOSObjectArray arrayWithLength:0 type:IOSClass_class_()]];
      [((JavaUtilHashMap *) nil_chk(self->mMethodHashMap_)) putWithId:str withId:method];
    }
    @catch (JavaLangNoSuchMethodException *e) {
      [((JavaUtilHashMap *) nil_chk(self->mMethodHashMap_)) putWithId:str withId:nil];
      ADLog_eWithNSString_withNSString_(ADXKeyTrigger_TAG, JreStrcat("$$$$C$", @"Could not find method \"", str, @"\"on class ", [[call java_getClass] getSimpleName], ' ', ADXCLDebug_getNameWithADView_(call)));
      return;
    }
  }
  @try {
    [((JavaLangReflectMethod *) nil_chk(method)) invokeWithId:call withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
  }
  @catch (JavaLangException *e) {
    ADLog_eWithNSString_withNSString_(ADXKeyTrigger_TAG, JreStrcat("$$$$C$", @"Exception in call \"", self->mCross_, @"\"on class ", [[((ADView *) nil_chk(call)) java_getClass] getSimpleName], ' ', ADXCLDebug_getNameWithADView_(call)));
  }
}

void ADXKeyTrigger_fireCustomWithNSString_withADView_(ADXKeyTrigger *self, NSString *str, ADView *view) {
  bool callAll = [((NSString *) nil_chk(str)) java_length] == 1;
  if (!callAll) {
    str = [((NSString *) nil_chk([str java_substring:1])) java_lowercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, ROOT)];
  }
  for (NSString * __strong name in nil_chk([((JavaUtilHashMap *) nil_chk(self->mCustomConstraints_)) keySet])) {
    NSString *lowerCase = [((NSString *) nil_chk(name)) java_lowercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, ROOT)];
    if (callAll || [((NSString *) nil_chk(lowerCase)) java_matches:str]) {
      ADXConstraintAttribute *custom = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(self->mCustomConstraints_)) getWithId:name]);
      if (custom != nil) {
        [custom applyCustomWithADView:view];
      }
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXKeyTrigger)

J2OBJC_NAME_MAPPING(ADXKeyTrigger, "androidx.constraintlayout.motion.widget", "ADX")

@implementation ADXKeyTrigger_Loader

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADXKeyTrigger_Loader_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LADXKeyTrigger;" };
  static const J2ObjcClassInfo _ADXKeyTrigger_Loader = { "Loader", "androidx.constraintlayout.motion.widget", ptrTable, methods, NULL, 7, 0xa, 1, 0, 0, -1, -1, -1, -1 };
  return &_ADXKeyTrigger_Loader;
}

@end

void ADXKeyTrigger_Loader_init(ADXKeyTrigger_Loader *self) {
  NSObject_init(self);
}

ADXKeyTrigger_Loader *new_ADXKeyTrigger_Loader_init() {
  J2OBJC_NEW_IMPL(ADXKeyTrigger_Loader, init)
}

ADXKeyTrigger_Loader *create_ADXKeyTrigger_Loader_init() {
  J2OBJC_CREATE_IMPL(ADXKeyTrigger_Loader, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXKeyTrigger_Loader)
