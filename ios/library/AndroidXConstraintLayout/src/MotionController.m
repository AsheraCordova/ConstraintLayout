//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroidXConstraintLayout\src\main\java\androidx\constraintlayout\motion\widget\MotionController.java
//

#define J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION 1




#include "AccelerateDecelerateInterpolator.h"
#include "AccelerateInterpolator.h"
#include "AnimationUtils.h"
#include "BounceInterpolator.h"
#include "CLDebug.h"
#include "ConstraintAttribute.h"
#include "ConstraintLayout.h"
#include "ConstraintSet.h"
#include "Context.h"
#include "CurveFit.h"
#include "DecelerateInterpolator.h"
#include "Easing.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "Interpolator.h"
#include "J2ObjC_source.h"
#include "Key.h"
#include "KeyAttributes.h"
#include "KeyCache.h"
#include "KeyCycle.h"
#include "KeyFrames.h"
#include "KeyPosition.h"
#include "KeyPositionBase.h"
#include "KeyTimeCycle.h"
#include "KeyTrigger.h"
#include "Log.h"
#include "MLMotionConstrainedPoint.h"
#include "MLMotionPaths.h"
#include "MotionController.h"
#include "OvershootInterpolator.h"
#include "Rect.h"
#include "RectF.h"
#include "Resources.h"
#include "SparseArray.h"
#include "SplineSet.h"
#include "VelocityMatrix.h"
#include "View.h"
#include "ViewGroup.h"
#include "ViewOscillator.h"
#include "ViewParent.h"
#include "ViewSpline.h"
#include "ViewState.h"
#include "ViewTimeCycle.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/LinkedHashMap.h"
#include "java/util/Set.h"


@class NSString;


#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic ignored "-Wswitch"


@interface ADXMotionController () {
 @public
  int32_t mCurveFitType_;
  ADXMLMotionPaths *mStartMotionPath_;
  ADXMLMotionPaths *mEndMotionPath_;
  ADXMLMotionConstrainedPoint *mStartPoint_;
  ADXMLMotionConstrainedPoint *mEndPoint_;
  IOSObjectArray *mSpline_;
  ADXCurveFit *mArcSpline_;
  IOSIntArray *mInterpolateVariables_;
  IOSDoubleArray *mInterpolateData_;
  IOSDoubleArray *mInterpolateVelocity_;
  IOSObjectArray *mAttributeNames_;
  IOSIntArray *mAttributeInterpolatorCount_;
  int32_t MAX_DIMENSION_;
  IOSFloatArray *mValuesBuff_;
  JavaUtilArrayList *mMLMotionPaths_;
  IOSFloatArray *mVelocity_;
  JavaUtilArrayList *mKeyList_;
  JavaUtilHashMap *mTimeCycleAttributesMap_;
  JavaUtilHashMap *mAttributesMap_;
  JavaUtilHashMap *mCycleMap_;
  IOSObjectArray *mKeyTriggers_;
  int32_t mPathMotionArc_;
  int32_t mTransformPivotTarget_;
  ADView *mTransformPivotView_;
  int32_t mQuantizeMotionSteps_;
  float mQuantizeMotionPhase_;
  id<ADInterpolator> mQuantizeMotionInterpolator_;
  bool mNoMovement_;
}

- (float)getPreCycleDistance;

- (void)insertKeyWithADXMLMotionPaths:(ADXMLMotionPaths *)point;

- (void)readViewWithADXMLMotionPaths:(ADXMLMotionPaths *)motionPaths;

+ (id<ADInterpolator>)getInterpolatorWithADContext:(ADContext *)context
                                           withInt:(int32_t)type
                                      withNSString:(NSString *)interpolatorString
                                           withInt:(int32_t)id_;

/*!
 @brief Calculates the adjusted (and optional velocity)
  Note if requesting velocity staggering is not considered
 @param position position pre stagger
 @param velocity return velocity
 @return actual position accounting for easing and staggering
 */
- (float)getAdjustedPositionWithFloat:(float)position
                       withFloatArray:(IOSFloatArray *)velocity;

@end

J2OBJC_FIELD_SETTER(ADXMotionController, mStartMotionPath_, ADXMLMotionPaths *)
J2OBJC_FIELD_SETTER(ADXMotionController, mEndMotionPath_, ADXMLMotionPaths *)
J2OBJC_FIELD_SETTER(ADXMotionController, mStartPoint_, ADXMLMotionConstrainedPoint *)
J2OBJC_FIELD_SETTER(ADXMotionController, mEndPoint_, ADXMLMotionConstrainedPoint *)
J2OBJC_FIELD_SETTER(ADXMotionController, mSpline_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mArcSpline_, ADXCurveFit *)
J2OBJC_FIELD_SETTER(ADXMotionController, mInterpolateVariables_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mInterpolateData_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mInterpolateVelocity_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mAttributeNames_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mAttributeInterpolatorCount_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mValuesBuff_, IOSFloatArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mMLMotionPaths_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADXMotionController, mVelocity_, IOSFloatArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mKeyList_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADXMotionController, mTimeCycleAttributesMap_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ADXMotionController, mAttributesMap_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ADXMotionController, mCycleMap_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(ADXMotionController, mKeyTriggers_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADXMotionController, mTransformPivotView_, ADView *)
J2OBJC_FIELD_SETTER(ADXMotionController, mQuantizeMotionInterpolator_, id<ADInterpolator>)

inline NSString *ADXMotionController_get_TAG(void);
static NSString *ADXMotionController_TAG = @"MotionController";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADXMotionController, TAG, NSString *)

inline bool ADXMotionController_get_DEBUG(void);
#define ADXMotionController_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotionController, DEBUG, bool)

inline bool ADXMotionController_get_FAVOR_FIXED_SIZE_VIEWS(void);
#define ADXMotionController_FAVOR_FIXED_SIZE_VIEWS false
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotionController, FAVOR_FIXED_SIZE_VIEWS, bool)

inline int32_t ADXMotionController_get_SPLINE_STRING(void);
#define ADXMotionController_SPLINE_STRING -1
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotionController, SPLINE_STRING, int32_t)

inline int32_t ADXMotionController_get_INTERPOLATOR_REFERENCE_ID(void);
#define ADXMotionController_INTERPOLATOR_REFERENCE_ID -2
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotionController, INTERPOLATOR_REFERENCE_ID, int32_t)

inline int32_t ADXMotionController_get_INTERPOLATOR_UNDEFINED(void);
#define ADXMotionController_INTERPOLATOR_UNDEFINED -3
J2OBJC_STATIC_FIELD_CONSTANT(ADXMotionController, INTERPOLATOR_UNDEFINED, int32_t)

__attribute__((unused)) static float ADXMotionController_getPreCycleDistance(ADXMotionController *self);

__attribute__((unused)) static void ADXMotionController_insertKeyWithADXMLMotionPaths_(ADXMotionController *self, ADXMLMotionPaths *point);

__attribute__((unused)) static void ADXMotionController_readViewWithADXMLMotionPaths_(ADXMotionController *self, ADXMLMotionPaths *motionPaths);

__attribute__((unused)) static id<ADInterpolator> ADXMotionController_getInterpolatorWithADContext_withInt_withNSString_withInt_(ADContext *context, int32_t type, NSString *interpolatorString, int32_t id_);

__attribute__((unused)) static float ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(ADXMotionController *self, float position, IOSFloatArray *velocity);

@interface ADXMotionController_1 : NSObject < ADInterpolator > {
 @public
  ADXEasing *val$easing_;
}

- (instancetype)initWithADXEasing:(ADXEasing *)capture$0;

- (float)getInterpolationWithFloat:(float)v;

@end

J2OBJC_EMPTY_STATIC_INIT(ADXMotionController_1)

__attribute__((unused)) static void ADXMotionController_1_initWithADXEasing_(ADXMotionController_1 *self, ADXEasing *capture$0);

__attribute__((unused)) static ADXMotionController_1 *new_ADXMotionController_1_initWithADXEasing_(ADXEasing *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADXMotionController_1 *create_ADXMotionController_1_initWithADXEasing_(ADXEasing *capture$0);


@implementation ADXMotionController

- (int32_t)getTransformPivotTarget {
  return mTransformPivotTarget_;
}

- (void)setTransformPivotTargetWithInt:(int32_t)transformPivotTarget {
  mTransformPivotTarget_ = transformPivotTarget;
  JreStrongAssign(&mTransformPivotView_, nil);
}

- (ADXMLMotionPaths *)getKeyFrameWithInt:(int32_t)i {
  return [((JavaUtilArrayList *) nil_chk(mMLMotionPaths_)) getWithInt:i];
}

- (instancetype)initWithADView:(ADView *)view {
  ADXMotionController_initWithADView_(self, view);
  return self;
}

- (float)getStartX {
  return ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_;
}

- (float)getStartY {
  return ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->y_;
}

- (float)getFinalX {
  return ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_;
}

- (float)getFinalY {
  return ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->y_;
}

- (float)getStartWidth {
  return ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->width_;
}

- (float)getStartHeight {
  return ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->height_;
}

- (float)getFinalWidth {
  return ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->width_;
}

- (float)getFinalHeight {
  return ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->height_;
}

- (int32_t)getAnimateRelativeTo {
  return ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->mAnimateRelativeTo_;
}

- (void)setupRelativeWithADXMotionController:(ADXMotionController *)motionController {
  [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setupRelativeWithADXMotionController:motionController withADXMLMotionPaths:((ADXMotionController *) nil_chk(motionController))->mStartMotionPath_];
  [((ADXMLMotionPaths *) nil_chk(mEndMotionPath_)) setupRelativeWithADXMotionController:motionController withADXMLMotionPaths:motionController->mEndMotionPath_];
}

- (float)getCenterX {
  return mCurrentCenterX_;
}

- (float)getCenterY {
  return mCurrentCenterY_;
}

- (void)getCenterWithDouble:(double)p
             withFloatArray:(IOSFloatArray *)pos
             withFloatArray:(IOSFloatArray *)vel {
  IOSDoubleArray *position = [IOSDoubleArray arrayWithLength:4];
  IOSDoubleArray *velocity = [IOSDoubleArray arrayWithLength:4];
  IOSIntArray *temp = [IOSIntArray arrayWithLength:4];
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:position];
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getSlopeWithDouble:p withDoubleArray:velocity];
  JavaUtilArrays_fillWithFloatArray_withFloat_(vel, 0);
  [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:p withIntArray:mInterpolateVariables_ withDoubleArray:position withFloatArray:pos withDoubleArray:velocity withFloatArray:vel];
}

- (void)buildPathWithFloatArray:(IOSFloatArray *)points
                        withInt:(int32_t)pointCount {
  float mils = 1.0f / (pointCount - 1);
  ADXSplineSet *trans_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_TRANSLATION_X];
  ADXSplineSet *trans_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_TRANSLATION_Y];
  ADXViewOscillator *osc_x = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_TRANSLATION_X];
  ADXViewOscillator *osc_y = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_TRANSLATION_Y];
  for (int32_t i = 0; i < pointCount; i++) {
    float position = (i) * mils;
    if (mStaggerScale_ != 1.0f) {
      if (position < mStaggerOffset_) {
        position = 0;
      }
      if (position > mStaggerOffset_ && position < 1.0) {
        JreMinusAssignFloatF(&position, mStaggerOffset_);
        JreTimesAssignFloatF(&position, mStaggerScale_);
        position = JavaLangMath_minWithFloat_withFloat_(position, 1.0f);
      }
    }
    double p = position;
    ADXEasing *easing = JreRetainedLocalValue(((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->mKeyFrameEasing_);
    float start = 0;
    float end = JavaLangFloat_NaN;
    for (ADXMLMotionPaths * __strong frame in nil_chk(mMLMotionPaths_)) {
      if (((ADXMLMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
        if (frame->time_ < position) {
          easing = frame->mKeyFrameEasing_;
          start = frame->time_;
        }
        else {
          if (JavaLangFloat_isNaNWithFloat_(end)) {
            end = frame->time_;
          }
        }
      }
    }
    if (easing != nil) {
      if (JavaLangFloat_isNaNWithFloat_(end)) {
        end = 1.0f;
      }
      float offset = (position - start) / (end - start);
      offset = (float) [easing getWithDouble:offset];
      p = offset * (end - start) + start;
    }
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:mInterpolateData_];
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:p withDoubleArray:mInterpolateData_];
      }
    }
    [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:p withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:points withInt:i * 2];
    if (osc_x != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2), [osc_x getWithFloat:position]);
    }
    else if (trans_x != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2), [trans_x getWithFloat:position]);
    }
    if (osc_y != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2 + 1), [osc_y getWithFloat:position]);
    }
    else if (trans_y != nil) {
      JrePlusAssignFloatF(IOSFloatArray_GetRef(nil_chk(points), i * 2 + 1), [trans_y getWithFloat:position]);
    }
  }
}

- (IOSDoubleArray *)getPosWithDouble:(double)position {
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
  if (mArcSpline_ != nil) {
    if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
      [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
    }
  }
  return mInterpolateData_;
}

- (void)buildBoundsWithFloatArray:(IOSFloatArray *)bounds
                          withInt:(int32_t)pointCount {
  float mils = 1.0f / (pointCount - 1);
  ADXSplineSet *trans_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_TRANSLATION_X];
  ADXSplineSet *trans_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_TRANSLATION_Y];
  ADXViewOscillator *osc_x = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_TRANSLATION_X];
  ADXViewOscillator *osc_y = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_TRANSLATION_Y];
  for (int32_t i = 0; i < pointCount; i++) {
    float position = (i) * mils;
    if (mStaggerScale_ != 1.0f) {
      if (position < mStaggerOffset_) {
        position = 0;
      }
      if (position > mStaggerOffset_ && position < 1.0) {
        JreMinusAssignFloatF(&position, mStaggerOffset_);
        JreTimesAssignFloatF(&position, mStaggerScale_);
        position = JavaLangMath_minWithFloat_withFloat_(position, 1.0f);
      }
    }
    double p = position;
    ADXEasing *easing = JreRetainedLocalValue(((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->mKeyFrameEasing_);
    float start = 0;
    float end = JavaLangFloat_NaN;
    for (ADXMLMotionPaths * __strong frame in nil_chk(mMLMotionPaths_)) {
      if (((ADXMLMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
        if (frame->time_ < position) {
          easing = frame->mKeyFrameEasing_;
          start = frame->time_;
        }
        else {
          if (JavaLangFloat_isNaNWithFloat_(end)) {
            end = frame->time_;
          }
        }
      }
    }
    if (easing != nil) {
      if (JavaLangFloat_isNaNWithFloat_(end)) {
        end = 1.0f;
      }
      float offset = (position - start) / (end - start);
      offset = (float) [easing getWithDouble:offset];
      p = offset * (end - start) + start;
    }
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:mInterpolateData_];
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:p withDoubleArray:mInterpolateData_];
      }
    }
    [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getBoundsWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:bounds withInt:i * 2];
  }
}

- (float)getPreCycleDistance {
  return ADXMotionController_getPreCycleDistance(self);
}

- (ADXKeyPositionBase *)getPositionKeyframeWithInt:(int32_t)layoutWidth
                                           withInt:(int32_t)layoutHeight
                                         withFloat:(float)x
                                         withFloat:(float)y {
  ADRectF *start = create_ADRectF_init();
  start->left_ = ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_;
  start->top_ = mStartMotionPath_->y_;
  start->right_ = start->left_ + mStartMotionPath_->width_;
  start->bottom_ = start->top_ + mStartMotionPath_->height_;
  ADRectF *end = create_ADRectF_init();
  end->left_ = ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_;
  end->top_ = mEndMotionPath_->y_;
  end->right_ = end->left_ + mEndMotionPath_->width_;
  end->bottom_ = end->top_ + mEndMotionPath_->height_;
  for (ADXKey * __strong key in nil_chk(mKeyList_)) {
    if ([key isKindOfClass:[ADXKeyPositionBase class]]) {
      if ([((ADXKeyPositionBase *) nil_chk(((ADXKeyPositionBase *) key))) intersectsWithInt:layoutWidth withInt:layoutHeight withADRectF:start withADRectF:end withFloat:x withFloat:y]) {
        return (ADXKeyPositionBase *) key;
      }
    }
  }
  return nil;
}

- (int32_t)buildKeyFramesWithFloatArray:(IOSFloatArray *)keyFrames
                           withIntArray:(IOSIntArray *)mode {
  if (keyFrames != nil) {
    int32_t count = 0;
    IOSDoubleArray *time = [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getTimePoints];
    if (mode != nil) {
      for (ADXMLMotionPaths * __strong keyFrame in nil_chk(mMLMotionPaths_)) {
        *IOSIntArray_GetRef(mode, count++) = ((ADXMLMotionPaths *) nil_chk(keyFrame))->mMode_;
      }
      count = 0;
    }
    for (int32_t i = 0; i < ((IOSDoubleArray *) nil_chk(time))->size_; i++) {
      [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:IOSDoubleArray_Get(time, i) withDoubleArray:mInterpolateData_];
      [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:IOSDoubleArray_Get(time, i) withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:keyFrames withInt:count];
      count += 2;
    }
    return JreIntDiv(count, 2);
  }
  return 0;
}

- (int32_t)buildKeyBoundsWithFloatArray:(IOSFloatArray *)keyBounds
                           withIntArray:(IOSIntArray *)mode {
  if (keyBounds != nil) {
    int32_t count = 0;
    IOSDoubleArray *time = [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getTimePoints];
    if (mode != nil) {
      for (ADXMLMotionPaths * __strong keyFrame in nil_chk(mMLMotionPaths_)) {
        *IOSIntArray_GetRef(mode, count++) = ((ADXMLMotionPaths *) nil_chk(keyFrame))->mMode_;
      }
      count = 0;
    }
    for (int32_t i = 0; i < ((IOSDoubleArray *) nil_chk(time))->size_; i++) {
      [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:IOSDoubleArray_Get(time, i) withDoubleArray:mInterpolateData_];
      [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getBoundsWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:keyBounds withInt:count];
      count += 2;
    }
    return JreIntDiv(count, 2);
  }
  return 0;
}

- (int32_t)getAttributeValuesWithNSString:(NSString *)attributeType
                           withFloatArray:(IOSFloatArray *)points
                                  withInt:(int32_t)pointCount {
  float mils = 1.0f / (pointCount - 1);
  ADXSplineSet *spline = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:attributeType]);
  if (spline == nil) {
    return -1;
  }
  for (int32_t j = 0; j < ((IOSFloatArray *) nil_chk(points))->size_; j++) {
    *IOSFloatArray_GetRef(points, j) = [spline getWithFloat:JreIntDiv(j, (points->size_ - 1))];
  }
  return points->size_;
}

- (void)buildRectWithFloat:(float)p
            withFloatArray:(IOSFloatArray *)path
                   withInt:(int32_t)offset {
  p = ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(self, p, nil);
  [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:p withDoubleArray:mInterpolateData_];
  [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getRectWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:path withInt:offset];
}

- (void)buildRectanglesWithFloatArray:(IOSFloatArray *)path
                              withInt:(int32_t)pointCount {
  float mils = 1.0f / (pointCount - 1);
  for (int32_t i = 0; i < pointCount; i++) {
    float position = (i) * mils;
    position = ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(self, position, nil);
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getRectWithIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:path withInt:i * 8];
  }
}

- (float)getKeyFrameParameterWithInt:(int32_t)type
                           withFloat:(float)x
                           withFloat:(float)y {
  float dx = ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_ - ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_;
  float dy = mEndMotionPath_->y_ - mStartMotionPath_->y_;
  float startCenterX = mStartMotionPath_->x_ + mStartMotionPath_->width_ / 2;
  float startCenterY = mStartMotionPath_->y_ + mStartMotionPath_->height_ / 2;
  float hypotenuse = (float) JavaLangMath_hypotWithDouble_withDouble_(dx, dy);
  if (hypotenuse < 0.0000001) {
    return JavaLangFloat_NaN;
  }
  float vx = x - startCenterX;
  float vy = y - startCenterY;
  float distFromStart = (float) JavaLangMath_hypotWithDouble_withDouble_(vx, vy);
  if (distFromStart == 0) {
    return 0;
  }
  float pathDistance = (vx * dx + vy * dy);
  switch (type) {
    case ADXMotionController_PATH_PERCENT:
    return pathDistance / hypotenuse;
    case ADXMotionController_PATH_PERPENDICULAR:
    return (float) JavaLangMath_sqrtWithDouble_(hypotenuse * hypotenuse - pathDistance * pathDistance);
    case ADXMotionController_HORIZONTAL_PATH_X:
    return vx / dx;
    case ADXMotionController_HORIZONTAL_PATH_Y:
    return vy / dx;
    case ADXMotionController_VERTICAL_PATH_X:
    return vx / dy;
    case ADXMotionController_VERTICAL_PATH_Y:
    return vy / dy;
  }
  return 0;
}

- (void)insertKeyWithADXMLMotionPaths:(ADXMLMotionPaths *)point {
  ADXMotionController_insertKeyWithADXMLMotionPaths_(self, point);
}

- (void)addKeysWithJavaUtilArrayList:(JavaUtilArrayList *)list {
  [((JavaUtilArrayList *) nil_chk(mKeyList_)) addAllWithJavaUtilCollection:list];
}

- (void)addKeyWithADXKey:(ADXKey *)key {
  [((JavaUtilArrayList *) nil_chk(mKeyList_)) addWithId:key];
}

- (void)setPathMotionArcWithInt:(int32_t)arc {
  mPathMotionArc_ = arc;
}

- (void)setupWithInt:(int32_t)parentWidth
             withInt:(int32_t)parentHeight
           withFloat:(float)transitionDuration
            withLong:(int64_t)currentTime {
  JavaUtilHashSet *springAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashSet *timeCycleAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashSet *splineAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashSet *cycleAttributes = create_JavaUtilHashSet_init();
  JavaUtilHashMap *interpolation = create_JavaUtilHashMap_init();
  JavaUtilArrayList *triggerList = nil;
  if (mPathMotionArc_ != JreLoadStatic(ADXKey, UNSET)) {
    ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->mPathMotionArc_ = mPathMotionArc_;
  }
  [((ADXMLMotionConstrainedPoint *) nil_chk(mStartPoint_)) differentWithADXMLMotionConstrainedPoint:mEndPoint_ withJavaUtilHashSet:splineAttributes];
  if (mKeyList_ != nil) {
    for (ADXKey * __strong key in mKeyList_) {
      if ([key isKindOfClass:[ADXKeyPosition class]]) {
        ADXKeyPosition *keyPath = (ADXKeyPosition *) key;
        ADXMotionController_insertKeyWithADXMLMotionPaths_(self, create_ADXMLMotionPaths_initPackagePrivateWithInt_withInt_withADXKeyPosition_withADXMLMotionPaths_withADXMLMotionPaths_(parentWidth, parentHeight, keyPath, mStartMotionPath_, mEndMotionPath_));
        if (((ADXKeyPosition *) nil_chk(keyPath))->mCurveFit_ != JreLoadStatic(ADXKey, UNSET)) {
          mCurveFitType_ = keyPath->mCurveFit_;
        }
      }
      else if ([key isKindOfClass:[ADXKeyCycle class]]) {
        [((ADXKey *) nil_chk(key)) getAttributeNamesWithJavaUtilHashSet:cycleAttributes];
      }
      else if ([key isKindOfClass:[ADXKeyTimeCycle class]]) {
        [((ADXKey *) nil_chk(key)) getAttributeNamesWithJavaUtilHashSet:timeCycleAttributes];
      }
      else if ([key isKindOfClass:[ADXKeyTrigger class]]) {
        if (triggerList == nil) {
          triggerList = create_JavaUtilArrayList_init();
        }
        [triggerList addWithId:(ADXKeyTrigger *) key];
      }
      else {
        [((ADXKey *) nil_chk(key)) setInterpolationWithJavaUtilHashMap:interpolation];
        [key getAttributeNamesWithJavaUtilHashSet:splineAttributes];
      }
    }
  }
  if (triggerList != nil) {
    JreStrongAssign(&mKeyTriggers_, [triggerList toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:0 type:ADXKeyTrigger_class_()]]);
  }
  if (![splineAttributes isEmpty]) {
    JreStrongAssignAndConsume(&mAttributesMap_, new_JavaUtilHashMap_init());
    for (NSString * __strong attribute in splineAttributes) {
      ADXViewSpline *splineSets;
      if ([((NSString *) nil_chk(attribute)) java_hasPrefix:@"CUSTOM,"]) {
        ADSparseArray *attrList = create_ADSparseArray_init();
        NSString *customAttributeName = IOSObjectArray_Get(nil_chk([attribute java_split:@","]), 1);
        for (ADXKey * __strong key in nil_chk(mKeyList_)) {
          if (((ADXKey *) nil_chk(key))->mCustomConstraints_ == nil) {
            continue;
          }
          ADXConstraintAttribute *customAttribute = JreRetainedLocalValue([key->mCustomConstraints_ getWithId:customAttributeName]);
          if (customAttribute != nil) {
            [attrList appendWithInt:key->mFramePosition_ withId:customAttribute];
          }
        }
        splineSets = ADXViewSpline_makeCustomSplineWithNSString_withADSparseArray_(attribute, attrList);
      }
      else {
        splineSets = ADXViewSpline_makeSplineWithNSString_(attribute);
      }
      if (splineSets == nil) {
        continue;
      }
      [splineSets setTypeWithNSString:attribute];
      [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) putWithId:attribute withId:splineSets];
    }
    if (mKeyList_ != nil) {
      for (ADXKey * __strong key in mKeyList_) {
        if (([key isKindOfClass:[ADXKeyAttributes class]])) {
          [((ADXKey *) nil_chk(key)) addValuesWithJavaUtilHashMap:mAttributesMap_];
        }
      }
    }
    [((ADXMLMotionConstrainedPoint *) nil_chk(mStartPoint_)) addValuesWithJavaUtilHashMap:mAttributesMap_ withInt:0];
    [((ADXMLMotionConstrainedPoint *) nil_chk(mEndPoint_)) addValuesWithJavaUtilHashMap:mAttributesMap_ withInt:100];
    for (NSString * __strong spline in nil_chk([((JavaUtilHashMap *) nil_chk(mAttributesMap_)) keySet])) {
      int32_t curve = ADXCurveFit_SPLINE;
      if ([interpolation containsKeyWithId:spline]) {
        JavaLangInteger *boxedCurve = JreRetainedLocalValue([interpolation getWithId:spline]);
        if (boxedCurve != nil) {
          curve = [boxedCurve intValue];
        }
      }
      ADXSplineSet *splineSet = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:spline]);
      if (splineSet != nil) {
        [splineSet setupWithInt:curve];
      }
    }
  }
  if (![timeCycleAttributes isEmpty]) {
    if (mTimeCycleAttributesMap_ == nil) {
      JreStrongAssignAndConsume(&mTimeCycleAttributesMap_, new_JavaUtilHashMap_init());
    }
    for (NSString * __strong attribute in timeCycleAttributes) {
      if ([((JavaUtilHashMap *) nil_chk(mTimeCycleAttributesMap_)) containsKeyWithId:attribute]) {
        continue;
      }
      ADXViewTimeCycle *splineSets = nil;
      if ([((NSString *) nil_chk(attribute)) java_hasPrefix:@"CUSTOM,"]) {
        ADSparseArray *attrList = create_ADSparseArray_init();
        NSString *customAttributeName = IOSObjectArray_Get(nil_chk([attribute java_split:@","]), 1);
        for (ADXKey * __strong key in nil_chk(mKeyList_)) {
          if (((ADXKey *) nil_chk(key))->mCustomConstraints_ == nil) {
            continue;
          }
          ADXConstraintAttribute *customAttribute = JreRetainedLocalValue([key->mCustomConstraints_ getWithId:customAttributeName]);
          if (customAttribute != nil) {
            [attrList appendWithInt:key->mFramePosition_ withId:customAttribute];
          }
        }
        splineSets = ADXViewTimeCycle_makeCustomSplineWithNSString_withADSparseArray_(attribute, attrList);
      }
      else {
        splineSets = ADXViewTimeCycle_makeSplineWithNSString_withLong_(attribute, currentTime);
      }
      if (splineSets == nil) {
        continue;
      }
      [splineSets setTypeWithNSString:attribute];
      [((JavaUtilHashMap *) nil_chk(mTimeCycleAttributesMap_)) putWithId:attribute withId:splineSets];
    }
    if (mKeyList_ != nil) {
      for (ADXKey * __strong key in mKeyList_) {
        if ([key isKindOfClass:[ADXKeyTimeCycle class]]) {
          [((ADXKeyTimeCycle *) nil_chk(((ADXKeyTimeCycle *) key))) addTimeValuesWithJavaUtilHashMap:mTimeCycleAttributesMap_];
        }
      }
    }
    for (NSString * __strong spline in nil_chk([mTimeCycleAttributesMap_ keySet])) {
      int32_t curve = ADXCurveFit_SPLINE;
      if ([interpolation containsKeyWithId:spline]) {
        curve = [((JavaLangInteger *) nil_chk([interpolation getWithId:spline])) intValue];
      }
      [((ADXViewTimeCycle *) nil_chk([((JavaUtilHashMap *) nil_chk(mTimeCycleAttributesMap_)) getWithId:spline])) setupWithInt:curve];
    }
  }
  IOSObjectArray *points = [IOSObjectArray arrayWithLength:2 + [((JavaUtilArrayList *) nil_chk(mMLMotionPaths_)) size] type:ADXMLMotionPaths_class_()];
  int32_t count = 1;
  IOSObjectArray_Set(points, 0, mStartMotionPath_);
  IOSObjectArray_Set(points, points->size_ - 1, mEndMotionPath_);
  if ([((JavaUtilArrayList *) nil_chk(mMLMotionPaths_)) size] > 0 && mCurveFitType_ == ADXKeyFrames_UNSET) {
    mCurveFitType_ = ADXCurveFit_SPLINE;
  }
  for (ADXMLMotionPaths * __strong point in nil_chk(mMLMotionPaths_)) {
    IOSObjectArray_Set(points, count++, point);
  }
  int32_t variables = 18;
  JavaUtilHashSet *attributeNameSet = create_JavaUtilHashSet_init();
  for (NSString * __strong s in nil_chk([((JavaUtilLinkedHashMap *) nil_chk(((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->attributes_)) keySet])) {
    if ([((JavaUtilLinkedHashMap *) nil_chk(((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->attributes_)) containsKeyWithId:s]) {
      if (![splineAttributes containsWithId:JreStrcat("$$", @"CUSTOM,", s)]) [attributeNameSet addWithId:s];
    }
  }
  JreStrongAssign(&mAttributeNames_, [attributeNameSet toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSString_class_()]]);
  JreStrongAssignAndConsume(&mAttributeInterpolatorCount_, [IOSIntArray newArrayWithLength:((IOSObjectArray *) nil_chk(mAttributeNames_))->size_]);
  for (int32_t i = 0; i < ((IOSObjectArray *) nil_chk(mAttributeNames_))->size_; i++) {
    NSString *attributeName = IOSObjectArray_Get(mAttributeNames_, i);
    *IOSIntArray_GetRef(nil_chk(mAttributeInterpolatorCount_), i) = 0;
    for (int32_t j = 0; j < points->size_; j++) {
      if ([((JavaUtilLinkedHashMap *) nil_chk(((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, j)))->attributes_)) containsKeyWithId:attributeName]) {
        ADXConstraintAttribute *attribute = JreRetainedLocalValue([((JavaUtilLinkedHashMap *) nil_chk(((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, j)))->attributes_)) getWithId:attributeName]);
        if (attribute != nil) {
          *IOSIntArray_GetRef(nil_chk(mAttributeInterpolatorCount_), i) += [attribute numberOfInterpolatedValues];
          break;
        }
      }
    }
  }
  bool arcMode = ((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, 0)))->mPathMotionArc_ != JreLoadStatic(ADXKey, UNSET);
  IOSBooleanArray *mask = [IOSBooleanArray arrayWithLength:variables + mAttributeNames_->size_];
  for (int32_t i = 1; i < points->size_; i++) {
    [((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, i))) differentWithADXMLMotionPaths:IOSObjectArray_Get(points, i - 1) withBooleanArray:mask withNSStringArray:mAttributeNames_ withBoolean:arcMode];
  }
  count = 0;
  for (int32_t i = 1; i < mask->size_; i++) {
    if (IOSBooleanArray_Get(mask, i)) {
      count++;
    }
  }
  JreStrongAssignAndConsume(&mInterpolateVariables_, [IOSIntArray newArrayWithLength:count]);
  int32_t varLen = JavaLangMath_maxWithInt_withInt_(2, count);
  JreStrongAssignAndConsume(&mInterpolateData_, [IOSDoubleArray newArrayWithLength:varLen]);
  JreStrongAssignAndConsume(&mInterpolateVelocity_, [IOSDoubleArray newArrayWithLength:varLen]);
  count = 0;
  for (int32_t i = 1; i < mask->size_; i++) {
    if (IOSBooleanArray_Get(mask, i)) *IOSIntArray_GetRef(nil_chk(mInterpolateVariables_), count++) = i;
  }
  IOSObjectArray *splineData = [IOSDoubleArray arrayWithDimensions:2 lengths:(int32_t[]){ points->size_, ((IOSIntArray *) nil_chk(mInterpolateVariables_))->size_ }];
  IOSDoubleArray *timePoint = [IOSDoubleArray arrayWithLength:points->size_];
  for (int32_t i = 0; i < points->size_; i++) {
    [((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, i))) fillStandardWithDoubleArray:IOSObjectArray_Get(splineData, i) withIntArray:mInterpolateVariables_];
    *IOSDoubleArray_GetRef(timePoint, i) = ((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->time_;
  }
  for (int32_t j = 0; j < ((IOSIntArray *) nil_chk(mInterpolateVariables_))->size_; j++) {
    int32_t interpolateVariable = IOSIntArray_Get(mInterpolateVariables_, j);
    if (interpolateVariable < ((IOSObjectArray *) nil_chk(JreLoadStatic(ADXMLMotionPaths, names)))->size_) {
      NSString *s = JreStrcat("$$", IOSObjectArray_Get(JreLoadStatic(ADXMLMotionPaths, names), IOSIntArray_Get(mInterpolateVariables_, j)), @" [");
      for (int32_t i = 0; i < points->size_; i++) {
        JreStrAppend(&s, "D", IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(splineData, i)), j));
      }
    }
  }
  JreStrongAssignAndConsume(&mSpline_, [IOSObjectArray newArrayWithLength:1 + ((IOSObjectArray *) nil_chk(mAttributeNames_))->size_ type:ADXCurveFit_class_()]);
  for (int32_t i = 0; i < ((IOSObjectArray *) nil_chk(mAttributeNames_))->size_; i++) {
    int32_t pointCount = 0;
    IOSObjectArray *splinePoints = nil;
    IOSDoubleArray *timePoints = nil;
    NSString *name = IOSObjectArray_Get(mAttributeNames_, i);
    for (int32_t j = 0; j < points->size_; j++) {
      if ([((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, j))) hasCustomDataWithNSString:name]) {
        if (splinePoints == nil) {
          timePoints = [IOSDoubleArray arrayWithLength:points->size_];
          splinePoints = [IOSDoubleArray arrayWithDimensions:2 lengths:(int32_t[]){ points->size_, [((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, j))) getCustomDataCountWithNSString:name] }];
        }
        *IOSDoubleArray_GetRef(nil_chk(timePoints), pointCount) = ((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, j)))->time_;
        [((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, j))) getCustomDataWithNSString:name withDoubleArray:IOSObjectArray_Get(splinePoints, pointCount) withInt:0];
        pointCount++;
      }
    }
    timePoints = JavaUtilArrays_copyOfWithDoubleArray_withInt_(timePoints, pointCount);
    splinePoints = JavaUtilArrays_copyOfWithNSObjectArray_withInt_(splinePoints, pointCount);
    IOSObjectArray_Set(nil_chk(mSpline_), i + 1, ADXCurveFit_getWithInt_withDoubleArray_withDoubleArray2_(mCurveFitType_, timePoints, splinePoints));
  }
  IOSObjectArray_Set(nil_chk(mSpline_), 0, ADXCurveFit_getWithInt_withDoubleArray_withDoubleArray2_(mCurveFitType_, timePoint, splineData));
  if (((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, 0)))->mPathMotionArc_ != JreLoadStatic(ADXKey, UNSET)) {
    int32_t size = points->size_;
    IOSIntArray *mode = [IOSIntArray arrayWithLength:size];
    IOSDoubleArray *time = [IOSDoubleArray arrayWithLength:size];
    IOSObjectArray *values = [IOSDoubleArray arrayWithDimensions:2 lengths:(int32_t[]){ size, 2 }];
    for (int32_t i = 0; i < size; i++) {
      *IOSIntArray_GetRef(mode, i) = ((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->mPathMotionArc_;
      *IOSDoubleArray_GetRef(time, i) = ((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->time_;
      *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(values, i)), 0) = ((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->x_;
      *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(values, i)), 1) = ((ADXMLMotionPaths *) nil_chk(IOSObjectArray_Get(points, i)))->y_;
    }
    JreStrongAssign(&mArcSpline_, ADXCurveFit_getArcWithIntArray_withDoubleArray_withDoubleArray2_(mode, time, values));
  }
  float distance = JavaLangFloat_NaN;
  JreStrongAssignAndConsume(&mCycleMap_, new_JavaUtilHashMap_init());
  if (mKeyList_ != nil) {
    for (NSString * __strong attribute in cycleAttributes) {
      ADXViewOscillator *cycle = ADXViewOscillator_makeSplineWithNSString_(attribute);
      if (cycle == nil) {
        continue;
      }
      if ([cycle variesByPath]) {
        if (JavaLangFloat_isNaNWithFloat_(distance)) {
          distance = ADXMotionController_getPreCycleDistance(self);
        }
      }
      [cycle setTypeWithNSString:attribute];
      [((JavaUtilHashMap *) nil_chk(mCycleMap_)) putWithId:attribute withId:cycle];
    }
    for (ADXKey * __strong key in mKeyList_) {
      if ([key isKindOfClass:[ADXKeyCycle class]]) {
        [((ADXKeyCycle *) nil_chk(((ADXKeyCycle *) key))) addCycleValuesWithJavaUtilHashMap:mCycleMap_];
      }
    }
    for (ADXViewOscillator * __strong cycle in nil_chk([mCycleMap_ values])) {
      [((ADXViewOscillator *) nil_chk(cycle)) setupWithFloat:distance];
    }
  }
}

- (NSString *)description {
  return JreStrcat("$F$F$F$F", @" start: x: ", ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_, @" y: ", mStartMotionPath_->y_, @" end: x: ", ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_, @" y: ", mEndMotionPath_->y_);
}

- (void)readViewWithADXMLMotionPaths:(ADXMLMotionPaths *)motionPaths {
  ADXMotionController_readViewWithADXMLMotionPaths_(self, motionPaths);
}

- (void)setViewWithADView:(ADView *)view {
  JreStrongAssign(&mView_, view);
  mId_ = [((ADView *) nil_chk(view)) getId];
  ADViewGroup_LayoutParams *lp = JreRetainedLocalValue([view getLayoutParams]);
  if ([lp isKindOfClass:[ADXConstraintLayout_LayoutParams class]]) {
    JreStrongAssign(&mConstraintTag_, [((ADXConstraintLayout_LayoutParams *) nil_chk(((ADXConstraintLayout_LayoutParams *) lp))) getConstraintTag]);
  }
}

- (ADView *)getView {
  return mView_;
}

- (void)setStartCurrentStateWithADView:(ADView *)v {
  ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->time_ = 0;
  mStartMotionPath_->position_ = 0;
  [mStartMotionPath_ setBoundsWithFloat:[((ADView *) nil_chk(v)) getX] withFloat:[v getY] withFloat:[v getWidth] withFloat:[v getHeight]];
  [((ADXMLMotionConstrainedPoint *) nil_chk(mStartPoint_)) setStateWithADView:v];
}

- (void)setStartStateWithADXViewState:(ADXViewState *)rect
                           withADView:(ADView *)v
                              withInt:(int32_t)rotation
                              withInt:(int32_t)preWidth
                              withInt:(int32_t)preHeight {
  ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->time_ = 0;
  mStartMotionPath_->position_ = 0;
  int32_t cx;
  int32_t cy;
  ADRect *r = create_ADRect_init();
  switch (rotation) {
    case 2:
    cx = ((ADXViewState *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    r->left_ = preHeight - JreIntDiv((cy + [rect width]), 2);
    r->top_ = JreIntDiv((cx - [rect height]), 2);
    r->right_ = r->left_ + [rect width];
    r->bottom_ = r->top_ + [rect height];
    break;
    case 1:
    cx = ((ADXViewState *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    r->left_ = JreIntDiv((cy - [rect width]), 2);
    r->top_ = preWidth - JreIntDiv((cx + [rect height]), 2);
    r->right_ = r->left_ + [rect width];
    r->bottom_ = r->top_ + [rect height];
    break;
  }
  [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setBoundsWithFloat:r->left_ withFloat:r->top_ withFloat:[r width] withFloat:[r height]];
  [((ADXMLMotionConstrainedPoint *) nil_chk(mStartPoint_)) setStateWithADRect:r withADView:v withInt:rotation withFloat:((ADXViewState *) nil_chk(rect))->rotation_];
}

- (void)rotateWithADRect:(ADRect *)rect
              withADRect:(ADRect *)outArg
                 withInt:(int32_t)rotation
                 withInt:(int32_t)preHeight
                 withInt:(int32_t)preWidth {
  int32_t cx;
  int32_t cy;
  switch (rotation) {
    case ADXConstraintSet_ROTATE_PORTRATE_OF_LEFT:
    cx = ((ADRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    ((ADRect *) nil_chk(outArg))->left_ = preHeight - JreIntDiv((cy + [rect width]), 2);
    outArg->top_ = JreIntDiv((cx - [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
    case ADXConstraintSet_ROTATE_PORTRATE_OF_RIGHT:
    cx = ((ADRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    ((ADRect *) nil_chk(outArg))->left_ = JreIntDiv((cy - [rect width]), 2);
    outArg->top_ = preWidth - JreIntDiv((cx + [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
    case ADXConstraintSet_ROTATE_LEFT_OF_PORTRATE:
    cx = ((ADRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->bottom_ + rect->top_;
    ((ADRect *) nil_chk(outArg))->left_ = preHeight - JreIntDiv((cy + [rect width]), 2);
    outArg->top_ = JreIntDiv((cx - [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
    case ADXConstraintSet_ROTATE_RIGHT_OF_PORTRATE:
    cx = ((ADRect *) nil_chk(rect))->left_ + rect->right_;
    cy = rect->top_ + rect->bottom_;
    ((ADRect *) nil_chk(outArg))->left_ = JreIntDiv([rect height], 2) + rect->top_ - JreIntDiv(cx, 2);
    outArg->top_ = preWidth - JreIntDiv((cx + [rect height]), 2);
    outArg->right_ = outArg->left_ + [rect width];
    outArg->bottom_ = outArg->top_ + [rect height];
    break;
  }
}

- (void)setStartStateWithADRect:(ADRect *)cw
           withADXConstraintSet:(ADXConstraintSet *)constraintSet
                        withInt:(int32_t)parentWidth
                        withInt:(int32_t)parentHeight {
  int32_t rotate = ((ADXConstraintSet *) nil_chk(constraintSet))->mRotate_;
  if (rotate != 0) {
    [self rotateWithADRect:cw withADRect:mTempRect_ withInt:rotate withInt:parentWidth withInt:parentHeight];
  }
  ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->time_ = 0;
  mStartMotionPath_->position_ = 0;
  ADXMotionController_readViewWithADXMLMotionPaths_(self, mStartMotionPath_);
  [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setBoundsWithFloat:((ADRect *) nil_chk(cw))->left_ withFloat:cw->top_ withFloat:[cw width] withFloat:[cw height]];
  ADXConstraintSet_Constraint *constraint = JreRetainedLocalValue([constraintSet getParametersWithInt:mId_]);
  [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) applyParametersWithADXConstraintSet_Constraint:constraint];
  mMotionStagger_ = ((ADXConstraintSet_Motion *) nil_chk(((ADXConstraintSet_Constraint *) nil_chk(constraint))->motion_))->mMotionStagger_;
  [((ADXMLMotionConstrainedPoint *) nil_chk(mStartPoint_)) setStateWithADRect:cw withADXConstraintSet:constraintSet withInt:rotate withInt:mId_];
  mTransformPivotTarget_ = ((ADXConstraintSet_Transform *) nil_chk(constraint->transform_))->transformPivotTarget_;
  mQuantizeMotionSteps_ = constraint->motion_->mQuantizeMotionSteps_;
  mQuantizeMotionPhase_ = constraint->motion_->mQuantizeMotionPhase_;
  JreStrongAssign(&mQuantizeMotionInterpolator_, ADXMotionController_getInterpolatorWithADContext_withInt_withNSString_withInt_([((ADView *) nil_chk(mView_)) getContext], constraint->motion_->mQuantizeInterpolatorType_, constraint->motion_->mQuantizeInterpolatorString_, constraint->motion_->mQuantizeInterpolatorID_));
}

+ (id<ADInterpolator>)getInterpolatorWithADContext:(ADContext *)context
                                           withInt:(int32_t)type
                                      withNSString:(NSString *)interpolatorString
                                           withInt:(int32_t)id_ {
  return ADXMotionController_getInterpolatorWithADContext_withInt_withNSString_withInt_(context, type, interpolatorString, id_);
}

- (void)setEndStateWithADRect:(ADRect *)cw
         withADXConstraintSet:(ADXConstraintSet *)constraintSet
                      withInt:(int32_t)parentWidth
                      withInt:(int32_t)parentHeight {
  int32_t rotate = ((ADXConstraintSet *) nil_chk(constraintSet))->mRotate_;
  if (rotate != 0) {
    [self rotateWithADRect:cw withADRect:mTempRect_ withInt:rotate withInt:parentWidth withInt:parentHeight];
    cw = mTempRect_;
  }
  ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->time_ = 1;
  mEndMotionPath_->position_ = 1;
  ADXMotionController_readViewWithADXMLMotionPaths_(self, mEndMotionPath_);
  [((ADXMLMotionPaths *) nil_chk(mEndMotionPath_)) setBoundsWithFloat:((ADRect *) nil_chk(cw))->left_ withFloat:cw->top_ withFloat:[cw width] withFloat:[cw height]];
  [((ADXMLMotionPaths *) nil_chk(mEndMotionPath_)) applyParametersWithADXConstraintSet_Constraint:[constraintSet getParametersWithInt:mId_]];
  [((ADXMLMotionConstrainedPoint *) nil_chk(mEndPoint_)) setStateWithADRect:cw withADXConstraintSet:constraintSet withInt:rotate withInt:mId_];
}

- (void)setBothStatesWithADView:(ADView *)v {
  ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->time_ = 0;
  mStartMotionPath_->position_ = 0;
  mNoMovement_ = true;
  [mStartMotionPath_ setBoundsWithFloat:[((ADView *) nil_chk(v)) getX] withFloat:[v getY] withFloat:[v getWidth] withFloat:[v getHeight]];
  [((ADXMLMotionPaths *) nil_chk(mEndMotionPath_)) setBoundsWithFloat:[v getX] withFloat:[v getY] withFloat:[v getWidth] withFloat:[v getHeight]];
  [((ADXMLMotionConstrainedPoint *) nil_chk(mStartPoint_)) setStateWithADView:v];
  [((ADXMLMotionConstrainedPoint *) nil_chk(mEndPoint_)) setStateWithADView:v];
}

- (float)getAdjustedPositionWithFloat:(float)position
                       withFloatArray:(IOSFloatArray *)velocity {
  return ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(self, position, velocity);
}

- (void)endTriggerWithBoolean:(bool)start {
  if ([@"button" isEqual:ADXCLDebug_getNameWithADView_(mView_)]) if (mKeyTriggers_ != nil) {
    for (int32_t i = 0; i < ((IOSObjectArray *) nil_chk(mKeyTriggers_))->size_; i++) {
      [((ADXKeyTrigger *) nil_chk(IOSObjectArray_Get(mKeyTriggers_, i))) conditionallyFireWithFloat:start ? -100 : 100 withADView:mView_];
    }
  }
}

- (bool)interpolateWithADView:(ADView *)child
                    withFloat:(float)global_position
                     withLong:(int64_t)time
              withADXKeyCache:(ADXKeyCache *)keyCache {
  bool timeAnimation = false;
  float position = ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(self, global_position, nil);
  if (mQuantizeMotionSteps_ != JreLoadStatic(ADXKey, UNSET)) {
    float pin = position;
    float steps = 1.0f / mQuantizeMotionSteps_;
    float jump = (float) JavaLangMath_floorWithDouble_(position / steps) * steps;
    float section = (fmodf(position, steps)) / steps;
    if (!JavaLangFloat_isNaNWithFloat_(mQuantizeMotionPhase_)) {
      section = fmodf((section + mQuantizeMotionPhase_), 1);
    }
    if (mQuantizeMotionInterpolator_ != nil) {
      section = [mQuantizeMotionInterpolator_ getInterpolationWithFloat:section];
    }
    else {
      section = section > 0.5 ? 1 : 0;
    }
    position = section * steps + jump;
  }
  ADXViewTimeCycle_PathRotate *timePathRotate = nil;
  if (mAttributesMap_ != nil) {
    for (ADXViewSpline * __strong aSpline in nil_chk([mAttributesMap_ values])) {
      [((ADXViewSpline *) nil_chk(aSpline)) setPropertyWithADView:child withFloat:position];
    }
  }
  if (mTimeCycleAttributesMap_ != nil) {
    for (ADXViewTimeCycle * __strong aSpline in nil_chk([mTimeCycleAttributesMap_ values])) {
      if ([aSpline isKindOfClass:[ADXViewTimeCycle_PathRotate class]]) {
        timePathRotate = (ADXViewTimeCycle_PathRotate *) aSpline;
        continue;
      }
      timeAnimation |= [((ADXViewTimeCycle *) nil_chk(aSpline)) setPropertyWithADView:child withFloat:position withLong:time withADXKeyCache:keyCache];
    }
  }
  if (mSpline_ != nil) {
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(mSpline_, 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
        [((ADXCurveFit *) nil_chk(mArcSpline_)) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
      }
    }
    if (!mNoMovement_) {
      [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setViewWithFloat:position withADView:child withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:nil];
    }
    if (mTransformPivotTarget_ != JreLoadStatic(ADXKey, UNSET)) {
      if (mTransformPivotView_ == nil) {
        ADView *layout = (ADView *) cast_chk([((ADView *) nil_chk(child)) getParent], [ADView class]);
        JreStrongAssign(&mTransformPivotView_, [((ADView *) nil_chk(layout)) findViewByIdWithInt:mTransformPivotTarget_]);
      }
      if (mTransformPivotView_ != nil) {
        float cy = ([mTransformPivotView_ getTop] + [((ADView *) nil_chk(mTransformPivotView_)) getBottom]) / 2.0f;
        float cx = ([((ADView *) nil_chk(mTransformPivotView_)) getLeft] + [((ADView *) nil_chk(mTransformPivotView_)) getRight]) / 2.0f;
        if ([((ADView *) nil_chk(child)) getRight] - [child getLeft] > 0 && [child getBottom] - [child getTop] > 0) {
          float px = (cx - [child getLeft]);
          float py = (cy - [child getTop]);
          [child setPivotXWithFloat:px];
          [child setPivotYWithFloat:py];
        }
      }
    }
    if (mAttributesMap_ != nil) {
      for (ADXSplineSet * __strong aSpline in nil_chk([mAttributesMap_ values])) {
        if ([aSpline isKindOfClass:[ADXViewSpline_PathRotate class]] && ((IOSDoubleArray *) nil_chk(mInterpolateVelocity_))->size_ > 1) [((ADXViewSpline_PathRotate *) nil_chk(((ADXViewSpline_PathRotate *) cast_chk(aSpline, [ADXViewSpline_PathRotate class])))) setPathRotateWithADView:child withFloat:position withDouble:IOSDoubleArray_Get(nil_chk(mInterpolateVelocity_), 0) withDouble:IOSDoubleArray_Get(mInterpolateVelocity_, 1)];
      }
    }
    if (timePathRotate != nil) {
      timeAnimation |= [timePathRotate setPathRotateWithADView:child withADXKeyCache:keyCache withFloat:position withLong:time withDouble:IOSDoubleArray_Get(nil_chk(mInterpolateVelocity_), 0) withDouble:IOSDoubleArray_Get(mInterpolateVelocity_, 1)];
    }
    for (int32_t i = 1; i < ((IOSObjectArray *) nil_chk(mSpline_))->size_; i++) {
      ADXCurveFit *spline = IOSObjectArray_Get(mSpline_, i);
      [((ADXCurveFit *) nil_chk(spline)) getPosWithDouble:position withFloatArray:mValuesBuff_];
      [((ADXConstraintAttribute *) nil_chk([((JavaUtilLinkedHashMap *) nil_chk(((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->attributes_)) getWithId:IOSObjectArray_Get(nil_chk(mAttributeNames_), i - 1)])) setInterpolatedValueWithADView:child withFloatArray:mValuesBuff_];
    }
    if (((ADXMLMotionConstrainedPoint *) nil_chk(mStartPoint_))->mVisibilityMode_ == ADXConstraintSet_VISIBILITY_MODE_NORMAL) {
      if (position <= 0.0f) {
        [((ADView *) nil_chk(child)) setVisibilityWithInt:mStartPoint_->visibility_];
      }
      else if (position >= 1.0f) {
        [((ADView *) nil_chk(child)) setVisibilityWithInt:((ADXMLMotionConstrainedPoint *) nil_chk(mEndPoint_))->visibility_];
      }
      else if (((ADXMLMotionConstrainedPoint *) nil_chk(mEndPoint_))->visibility_ != mStartPoint_->visibility_) {
        [((ADView *) nil_chk(child)) setVisibilityWithInt:ADView_VISIBLE];
      }
    }
    if (mKeyTriggers_ != nil) {
      for (int32_t i = 0; i < ((IOSObjectArray *) nil_chk(mKeyTriggers_))->size_; i++) {
        [((ADXKeyTrigger *) nil_chk(IOSObjectArray_Get(mKeyTriggers_, i))) conditionallyFireWithFloat:position withADView:child];
      }
    }
  }
  else {
    float float_l = (((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_ + (((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_ - mStartMotionPath_->x_) * position);
    float float_t = (mStartMotionPath_->y_ + (mEndMotionPath_->y_ - mStartMotionPath_->y_) * position);
    float float_width = (mStartMotionPath_->width_ + (mEndMotionPath_->width_ - mStartMotionPath_->width_) * position);
    float float_height = (mStartMotionPath_->height_ + (mEndMotionPath_->height_ - mStartMotionPath_->height_) * position);
    int32_t l = JreFpToInt((0.5f + float_l));
    int32_t t = JreFpToInt((0.5f + float_t));
    int32_t r = JreFpToInt((0.5f + float_l + float_width));
    int32_t b = JreFpToInt((0.5f + float_t + float_height));
    int32_t width = r - l;
    int32_t height = b - t;
    if (mEndMotionPath_->width_ != mStartMotionPath_->width_ || mEndMotionPath_->height_ != mStartMotionPath_->height_) {
      int32_t widthMeasureSpec = ADView_MeasureSpec_makeMeasureSpecWithInt_withInt_(width, ADView_MeasureSpec_EXACTLY);
      int32_t heightMeasureSpec = ADView_MeasureSpec_makeMeasureSpecWithInt_withInt_(height, ADView_MeasureSpec_EXACTLY);
      [((ADView *) nil_chk(child)) measureWithInt:widthMeasureSpec withInt:heightMeasureSpec];
    }
    [((ADView *) nil_chk(child)) layoutWithInt:l withInt:t withInt:r withInt:b];
  }
  if (mCycleMap_ != nil) {
    for (ADXViewOscillator * __strong osc in nil_chk([mCycleMap_ values])) {
      if ([osc isKindOfClass:[ADXViewOscillator_PathRotateSet class]]) {
        [((ADXViewOscillator_PathRotateSet *) nil_chk(((ADXViewOscillator_PathRotateSet *) osc))) setPathRotateWithADView:child withFloat:position withDouble:IOSDoubleArray_Get(nil_chk(mInterpolateVelocity_), 0) withDouble:IOSDoubleArray_Get(mInterpolateVelocity_, 1)];
      }
      else {
        [((ADXViewOscillator *) nil_chk(osc)) setPropertyWithADView:child withFloat:position];
      }
    }
  }
  return timeAnimation;
}

- (void)getDpDtWithFloat:(float)position
               withFloat:(float)locationX
               withFloat:(float)locationY
          withFloatArray:(IOSFloatArray *)mAnchorDpDt {
  position = ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(self, position, mVelocity_);
  if (mSpline_ != nil) {
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(mSpline_, 0))) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    float v = IOSFloatArray_Get(nil_chk(mVelocity_), 0);
    for (int32_t i = 0; i < ((IOSDoubleArray *) nil_chk(mInterpolateVelocity_))->size_; i++) {
      JreTimesAssignDoubleD(IOSDoubleArray_GetRef(mInterpolateVelocity_, i), v);
    }
    if (mArcSpline_ != nil) {
      if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
        [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
        [((ADXCurveFit *) nil_chk(mArcSpline_)) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
        [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
      }
      return;
    }
    [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
    return;
  }
  float dleft = (((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_ - ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_);
  float dTop = (mEndMotionPath_->y_ - mStartMotionPath_->y_);
  float dWidth = (mEndMotionPath_->width_ - mStartMotionPath_->width_);
  float dHeight = (mEndMotionPath_->height_ - mStartMotionPath_->height_);
  float dRight = dleft + dWidth;
  float dBottom = dTop + dHeight;
  *IOSFloatArray_GetRef(nil_chk(mAnchorDpDt), 0) = dleft * (1 - locationX) + dRight * (locationX);
  *IOSFloatArray_GetRef(mAnchorDpDt, 1) = dTop * (1 - locationY) + dBottom * (locationY);
}

- (void)getPostLayoutDvDpWithFloat:(float)position
                           withInt:(int32_t)width
                           withInt:(int32_t)height
                         withFloat:(float)locationX
                         withFloat:(float)locationY
                    withFloatArray:(IOSFloatArray *)mAnchorDpDt {
  position = ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(self, position, mVelocity_);
  ADXSplineSet *trans_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_TRANSLATION_X];
  ADXSplineSet *trans_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_TRANSLATION_Y];
  ADXSplineSet *rotation = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_ROTATION];
  ADXSplineSet *scale_x = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_SCALE_X];
  ADXSplineSet *scale_y = (mAttributesMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mAttributesMap_)) getWithId:ADXKey_SCALE_Y];
  ADXViewOscillator *osc_x = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_TRANSLATION_X];
  ADXViewOscillator *osc_y = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_TRANSLATION_Y];
  ADXViewOscillator *osc_r = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_ROTATION];
  ADXViewOscillator *osc_sx = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_SCALE_X];
  ADXViewOscillator *osc_sy = (mCycleMap_ == nil) ? nil : [((JavaUtilHashMap *) nil_chk(mCycleMap_)) getWithId:ADXKey_SCALE_Y];
  ADXVelocityMatrix *vmat = create_ADXVelocityMatrix_init();
  [vmat clear];
  [vmat setRotationVelocityWithADXSplineSet:rotation withFloat:position];
  [vmat setTranslationVelocityWithADXSplineSet:trans_x withADXSplineSet:trans_y withFloat:position];
  [vmat setScaleVelocityWithADXSplineSet:scale_x withADXSplineSet:scale_y withFloat:position];
  [vmat setRotationVelocityWithADXKeyCycleOscillator:osc_r withFloat:position];
  [vmat setTranslationVelocityWithADXKeyCycleOscillator:osc_x withADXKeyCycleOscillator:osc_y withFloat:position];
  [vmat setScaleVelocityWithADXKeyCycleOscillator:osc_sx withADXKeyCycleOscillator:osc_sy withFloat:position];
  if (mArcSpline_ != nil) {
    if (((IOSDoubleArray *) nil_chk(mInterpolateData_))->size_ > 0) {
      [mArcSpline_ getPosWithDouble:position withDoubleArray:mInterpolateData_];
      [((ADXCurveFit *) nil_chk(mArcSpline_)) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
      [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
    }
    [vmat applyTransformWithFloat:locationX withFloat:locationY withInt:width withInt:height withFloatArray:mAnchorDpDt];
    return;
  }
  if (mSpline_ != nil) {
    position = ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(self, position, mVelocity_);
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getSlopeWithDouble:position withDoubleArray:mInterpolateVelocity_];
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:position withDoubleArray:mInterpolateData_];
    float v = IOSFloatArray_Get(nil_chk(mVelocity_), 0);
    for (int32_t i = 0; i < ((IOSDoubleArray *) nil_chk(mInterpolateVelocity_))->size_; i++) {
      JreTimesAssignDoubleD(IOSDoubleArray_GetRef(mInterpolateVelocity_, i), v);
    }
    [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) setDpDtWithFloat:locationX withFloat:locationY withFloatArray:mAnchorDpDt withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateVelocity_ withDoubleArray:mInterpolateData_];
    [vmat applyTransformWithFloat:locationX withFloat:locationY withInt:width withInt:height withFloatArray:mAnchorDpDt];
    return;
  }
  float dleft = (((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_ - ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_);
  float dTop = (mEndMotionPath_->y_ - mStartMotionPath_->y_);
  float dWidth = (mEndMotionPath_->width_ - mStartMotionPath_->width_);
  float dHeight = (mEndMotionPath_->height_ - mStartMotionPath_->height_);
  float dRight = dleft + dWidth;
  float dBottom = dTop + dHeight;
  *IOSFloatArray_GetRef(nil_chk(mAnchorDpDt), 0) = dleft * (1 - locationX) + dRight * (locationX);
  *IOSFloatArray_GetRef(mAnchorDpDt, 1) = dTop * (1 - locationY) + dBottom * (locationY);
  [vmat clear];
  [vmat setRotationVelocityWithADXSplineSet:rotation withFloat:position];
  [vmat setTranslationVelocityWithADXSplineSet:trans_x withADXSplineSet:trans_y withFloat:position];
  [vmat setScaleVelocityWithADXSplineSet:scale_x withADXSplineSet:scale_y withFloat:position];
  [vmat setRotationVelocityWithADXKeyCycleOscillator:osc_r withFloat:position];
  [vmat setTranslationVelocityWithADXKeyCycleOscillator:osc_x withADXKeyCycleOscillator:osc_y withFloat:position];
  [vmat setScaleVelocityWithADXKeyCycleOscillator:osc_sx withADXKeyCycleOscillator:osc_sy withFloat:position];
  [vmat applyTransformWithFloat:locationX withFloat:locationY withInt:width withInt:height withFloatArray:mAnchorDpDt];
  return;
}

- (int32_t)getDrawPath {
  int32_t mode = ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->mDrawPath_;
  for (ADXMLMotionPaths * __strong keyFrame in nil_chk(mMLMotionPaths_)) {
    mode = JavaLangMath_maxWithInt_withInt_(mode, ((ADXMLMotionPaths *) nil_chk(keyFrame))->mDrawPath_);
  }
  mode = JavaLangMath_maxWithInt_withInt_(mode, ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->mDrawPath_);
  return mode;
}

- (void)setDrawPathWithInt:(int32_t)debugMode {
  ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->mDrawPath_ = debugMode;
}

- (NSString *)name {
  ADContext *context = JreRetainedLocalValue([((ADView *) nil_chk(mView_)) getContext]);
  return [((ADResources *) nil_chk([((ADContext *) nil_chk(context)) getResources])) getResourceEntryNameWithInt:[((ADView *) nil_chk(mView_)) getId]];
}

- (void)positionKeyframeWithADView:(ADView *)view
            withADXKeyPositionBase:(ADXKeyPositionBase *)key
                         withFloat:(float)x
                         withFloat:(float)y
                 withNSStringArray:(IOSObjectArray *)attribute
                    withFloatArray:(IOSFloatArray *)value {
  ADRectF *start = create_ADRectF_init();
  start->left_ = ((ADXMLMotionPaths *) nil_chk(mStartMotionPath_))->x_;
  start->top_ = mStartMotionPath_->y_;
  start->right_ = start->left_ + mStartMotionPath_->width_;
  start->bottom_ = start->top_ + mStartMotionPath_->height_;
  ADRectF *end = create_ADRectF_init();
  end->left_ = ((ADXMLMotionPaths *) nil_chk(mEndMotionPath_))->x_;
  end->top_ = mEndMotionPath_->y_;
  end->right_ = end->left_ + mEndMotionPath_->width_;
  end->bottom_ = end->top_ + mEndMotionPath_->height_;
  [((ADXKeyPositionBase *) nil_chk(key)) positionAttributesWithADView:view withADRectF:start withADRectF:end withFloat:x withFloat:y withNSStringArray:attribute withFloatArray:value];
}

- (int32_t)getKeyFramePositionsWithIntArray:(IOSIntArray *)type
                             withFloatArray:(IOSFloatArray *)pos {
  int32_t i = 0;
  int32_t count = 0;
  for (ADXKey * __strong key in nil_chk(mKeyList_)) {
    *IOSIntArray_GetRef(nil_chk(type), i++) = ((ADXKey *) nil_chk(key))->mFramePosition_ + 1000 * key->mType_;
    float time = key->mFramePosition_ / 100.0f;
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:time withDoubleArray:mInterpolateData_];
    [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:time withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:pos withInt:count];
    count += 2;
  }
  return i;
}

- (int32_t)getKeyFrameInfoWithInt:(int32_t)type
                     withIntArray:(IOSIntArray *)info {
  int32_t count = 0;
  int32_t cursor = 0;
  IOSFloatArray *pos = [IOSFloatArray arrayWithLength:2];
  int32_t len;
  for (ADXKey * __strong key in nil_chk(mKeyList_)) {
    if (((ADXKey *) nil_chk(key))->mType_ != type && type == -1) {
      continue;
    }
    len = cursor;
    *IOSIntArray_GetRef(nil_chk(info), cursor) = 0;
    *IOSIntArray_GetRef(info, ++cursor) = key->mType_;
    *IOSIntArray_GetRef(info, ++cursor) = key->mFramePosition_;
    float time = key->mFramePosition_ / 100.0f;
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(mSpline_), 0))) getPosWithDouble:time withDoubleArray:mInterpolateData_];
    [((ADXMLMotionPaths *) nil_chk(mStartMotionPath_)) getCenterWithDouble:time withIntArray:mInterpolateVariables_ withDoubleArray:mInterpolateData_ withFloatArray:pos withInt:0];
    *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(IOSFloatArray_Get(pos, 0));
    *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(IOSFloatArray_Get(pos, 1));
    if ([key isKindOfClass:[ADXKeyPosition class]]) {
      ADXKeyPosition *kp = (ADXKeyPosition *) key;
      *IOSIntArray_GetRef(info, ++cursor) = kp->mPositionType_;
      *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(kp->mPercentX_);
      *IOSIntArray_GetRef(info, ++cursor) = JavaLangFloat_floatToIntBitsWithFloat_(kp->mPercentY_);
    }
    cursor++;
    *IOSIntArray_GetRef(info, len) = cursor - len;
    count++;
  }
  return count;
}

- (void)dealloc {
  RELEASE_(mTempRect_);
  RELEASE_(mView_);
  RELEASE_(mConstraintTag_);
  RELEASE_(mStartMotionPath_);
  RELEASE_(mEndMotionPath_);
  RELEASE_(mStartPoint_);
  RELEASE_(mEndPoint_);
  RELEASE_(mSpline_);
  RELEASE_(mArcSpline_);
  RELEASE_(mInterpolateVariables_);
  RELEASE_(mInterpolateData_);
  RELEASE_(mInterpolateVelocity_);
  RELEASE_(mAttributeNames_);
  RELEASE_(mAttributeInterpolatorCount_);
  RELEASE_(mValuesBuff_);
  RELEASE_(mMLMotionPaths_);
  RELEASE_(mVelocity_);
  RELEASE_(mKeyList_);
  RELEASE_(mTimeCycleAttributesMap_);
  RELEASE_(mAttributesMap_);
  RELEASE_(mCycleMap_);
  RELEASE_(mKeyTriggers_);
  RELEASE_(mTransformPivotView_);
  RELEASE_(mQuantizeMotionInterpolator_);
  RELEASE_(attributeTable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LADXMLMotionPaths;", 0x0, 2, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 3, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 8, 9, -1, -1, -1, -1 },
    { NULL, "[D", 0x0, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 12, 9, -1, -1, -1, -1 },
    { NULL, "F", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADXKeyPositionBase;", 0x0, 13, 14, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 15, 16, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 17, 16, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 18, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 20, 21, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 22, 9, -1, -1, -1, -1 },
    { NULL, "F", 0x0, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 25, 26, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 27, 28, -1, 29, -1, -1 },
    { NULL, "V", 0x1, 30, 31, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 32, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 33, 34, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 35, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 36, 26, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 37, 3, -1, -1, -1, -1 },
    { NULL, "LADView;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 38, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 39, 40, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 41, 42, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 39, 43, -1, -1, -1, -1 },
    { NULL, "LADInterpolator;", 0xa, 44, 45, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 46, 43, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 47, 3, -1, -1, -1, -1 },
    { NULL, "F", 0x2, 48, 49, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 50, 51, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 52, 53, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 54, 55, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 56, 57, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 58, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 59, 60, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 61, 62, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 63, 64, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(getTransformPivotTarget);
  methods[1].selector = @selector(setTransformPivotTargetWithInt:);
  methods[2].selector = @selector(getKeyFrameWithInt:);
  methods[3].selector = @selector(initWithADView:);
  methods[4].selector = @selector(getStartX);
  methods[5].selector = @selector(getStartY);
  methods[6].selector = @selector(getFinalX);
  methods[7].selector = @selector(getFinalY);
  methods[8].selector = @selector(getStartWidth);
  methods[9].selector = @selector(getStartHeight);
  methods[10].selector = @selector(getFinalWidth);
  methods[11].selector = @selector(getFinalHeight);
  methods[12].selector = @selector(getAnimateRelativeTo);
  methods[13].selector = @selector(setupRelativeWithADXMotionController:);
  methods[14].selector = @selector(getCenterX);
  methods[15].selector = @selector(getCenterY);
  methods[16].selector = @selector(getCenterWithDouble:withFloatArray:withFloatArray:);
  methods[17].selector = @selector(buildPathWithFloatArray:withInt:);
  methods[18].selector = @selector(getPosWithDouble:);
  methods[19].selector = @selector(buildBoundsWithFloatArray:withInt:);
  methods[20].selector = @selector(getPreCycleDistance);
  methods[21].selector = @selector(getPositionKeyframeWithInt:withInt:withFloat:withFloat:);
  methods[22].selector = @selector(buildKeyFramesWithFloatArray:withIntArray:);
  methods[23].selector = @selector(buildKeyBoundsWithFloatArray:withIntArray:);
  methods[24].selector = @selector(getAttributeValuesWithNSString:withFloatArray:withInt:);
  methods[25].selector = @selector(buildRectWithFloat:withFloatArray:withInt:);
  methods[26].selector = @selector(buildRectanglesWithFloatArray:withInt:);
  methods[27].selector = @selector(getKeyFrameParameterWithInt:withFloat:withFloat:);
  methods[28].selector = @selector(insertKeyWithADXMLMotionPaths:);
  methods[29].selector = @selector(addKeysWithJavaUtilArrayList:);
  methods[30].selector = @selector(addKeyWithADXKey:);
  methods[31].selector = @selector(setPathMotionArcWithInt:);
  methods[32].selector = @selector(setupWithInt:withInt:withFloat:withLong:);
  methods[33].selector = @selector(description);
  methods[34].selector = @selector(readViewWithADXMLMotionPaths:);
  methods[35].selector = @selector(setViewWithADView:);
  methods[36].selector = @selector(getView);
  methods[37].selector = @selector(setStartCurrentStateWithADView:);
  methods[38].selector = @selector(setStartStateWithADXViewState:withADView:withInt:withInt:withInt:);
  methods[39].selector = @selector(rotateWithADRect:withADRect:withInt:withInt:withInt:);
  methods[40].selector = @selector(setStartStateWithADRect:withADXConstraintSet:withInt:withInt:);
  methods[41].selector = @selector(getInterpolatorWithADContext:withInt:withNSString:withInt:);
  methods[42].selector = @selector(setEndStateWithADRect:withADXConstraintSet:withInt:withInt:);
  methods[43].selector = @selector(setBothStatesWithADView:);
  methods[44].selector = @selector(getAdjustedPositionWithFloat:withFloatArray:);
  methods[45].selector = @selector(endTriggerWithBoolean:);
  methods[46].selector = @selector(interpolateWithADView:withFloat:withLong:withADXKeyCache:);
  methods[47].selector = @selector(getDpDtWithFloat:withFloat:withFloat:withFloatArray:);
  methods[48].selector = @selector(getPostLayoutDvDpWithFloat:withInt:withInt:withFloat:withFloat:withFloatArray:);
  methods[49].selector = @selector(getDrawPath);
  methods[50].selector = @selector(setDrawPathWithInt:);
  methods[51].selector = @selector(name);
  methods[52].selector = @selector(positionKeyframeWithADView:withADXKeyPositionBase:withFloat:withFloat:withNSStringArray:withFloatArray:);
  methods[53].selector = @selector(getKeyFramePositionsWithIntArray:withFloatArray:);
  methods[54].selector = @selector(getKeyFrameInfoWithInt:withIntArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "PATH_PERCENT", "I", .constantValue.asInt = ADXMotionController_PATH_PERCENT, 0x19, -1, -1, -1, -1 },
    { "PATH_PERPENDICULAR", "I", .constantValue.asInt = ADXMotionController_PATH_PERPENDICULAR, 0x19, -1, -1, -1, -1 },
    { "HORIZONTAL_PATH_X", "I", .constantValue.asInt = ADXMotionController_HORIZONTAL_PATH_X, 0x19, -1, -1, -1, -1 },
    { "HORIZONTAL_PATH_Y", "I", .constantValue.asInt = ADXMotionController_HORIZONTAL_PATH_Y, 0x19, -1, -1, -1, -1 },
    { "VERTICAL_PATH_X", "I", .constantValue.asInt = ADXMotionController_VERTICAL_PATH_X, 0x19, -1, -1, -1, -1 },
    { "VERTICAL_PATH_Y", "I", .constantValue.asInt = ADXMotionController_VERTICAL_PATH_Y, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_NONE", "I", .constantValue.asInt = ADXMotionController_DRAW_PATH_NONE, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_BASIC", "I", .constantValue.asInt = ADXMotionController_DRAW_PATH_BASIC, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_RELATIVE", "I", .constantValue.asInt = ADXMotionController_DRAW_PATH_RELATIVE, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_CARTESIAN", "I", .constantValue.asInt = ADXMotionController_DRAW_PATH_CARTESIAN, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_AS_CONFIGURED", "I", .constantValue.asInt = ADXMotionController_DRAW_PATH_AS_CONFIGURED, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_RECTANGLE", "I", .constantValue.asInt = ADXMotionController_DRAW_PATH_RECTANGLE, 0x19, -1, -1, -1, -1 },
    { "DRAW_PATH_SCREEN", "I", .constantValue.asInt = ADXMotionController_DRAW_PATH_SCREEN, 0x19, -1, -1, -1, -1 },
    { "ROTATION_RIGHT", "I", .constantValue.asInt = ADXMotionController_ROTATION_RIGHT, 0x19, -1, -1, -1, -1 },
    { "ROTATION_LEFT", "I", .constantValue.asInt = ADXMotionController_ROTATION_LEFT, 0x19, -1, -1, -1, -1 },
    { "mTempRect_", "LADRect;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 65, -1, -1 },
    { "DEBUG", "Z", .constantValue.asBOOL = ADXMotionController_DEBUG, 0x1a, -1, -1, -1, -1 },
    { "FAVOR_FIXED_SIZE_VIEWS", "Z", .constantValue.asBOOL = ADXMotionController_FAVOR_FIXED_SIZE_VIEWS, 0x1a, -1, -1, -1, -1 },
    { "mView_", "LADView;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mId_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mConstraintTag_", "LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCurveFitType_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStartMotionPath_", "LADXMLMotionPaths;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mEndMotionPath_", "LADXMLMotionPaths;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStartPoint_", "LADXMLMotionConstrainedPoint;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mEndPoint_", "LADXMLMotionConstrainedPoint;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSpline_", "[LADXCurveFit;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mArcSpline_", "LADXCurveFit;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMotionStagger_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mStaggerOffset_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mStaggerScale_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCurrentCenterX_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mCurrentCenterY_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mInterpolateVariables_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInterpolateData_", "[D", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInterpolateVelocity_", "[D", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAttributeNames_", "[LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAttributeInterpolatorCount_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "MAX_DIMENSION_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mValuesBuff_", "[F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMLMotionPaths_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x2, -1, -1, 66, -1 },
    { "mVelocity_", "[F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mKeyList_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x2, -1, -1, 67, -1 },
    { "mTimeCycleAttributesMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x2, -1, -1, 68, -1 },
    { "mAttributesMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x2, -1, -1, 69, -1 },
    { "mCycleMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x2, -1, -1, 70, -1 },
    { "mKeyTriggers_", "[LADXKeyTrigger;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPathMotionArc_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTransformPivotTarget_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTransformPivotView_", "LADView;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mQuantizeMotionSteps_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mQuantizeMotionPhase_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mQuantizeMotionInterpolator_", "LADInterpolator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mNoMovement_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "attributeTable_", "[LNSString;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "EASE_IN_OUT", "I", .constantValue.asInt = ADXMotionController_EASE_IN_OUT, 0x18, -1, -1, -1, -1 },
    { "EASE_IN", "I", .constantValue.asInt = ADXMotionController_EASE_IN, 0x18, -1, -1, -1, -1 },
    { "EASE_OUT", "I", .constantValue.asInt = ADXMotionController_EASE_OUT, 0x18, -1, -1, -1, -1 },
    { "LINEAR", "I", .constantValue.asInt = ADXMotionController_LINEAR, 0x18, -1, -1, -1, -1 },
    { "BOUNCE", "I", .constantValue.asInt = ADXMotionController_BOUNCE, 0x18, -1, -1, -1, -1 },
    { "OVERSHOOT", "I", .constantValue.asInt = ADXMotionController_OVERSHOOT, 0x18, -1, -1, -1, -1 },
    { "SPLINE_STRING", "I", .constantValue.asInt = ADXMotionController_SPLINE_STRING, 0x1a, -1, -1, -1, -1 },
    { "INTERPOLATOR_REFERENCE_ID", "I", .constantValue.asInt = ADXMotionController_INTERPOLATOR_REFERENCE_ID, 0x1a, -1, -1, -1, -1 },
    { "INTERPOLATOR_UNDEFINED", "I", .constantValue.asInt = ADXMotionController_INTERPOLATOR_UNDEFINED, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setTransformPivotTarget", "I", "getKeyFrame", "LADView;", "setupRelative", "LADXMotionController;", "getCenter", "D[F[F", "buildPath", "[FI", "getPos", "D", "buildBounds", "getPositionKeyframe", "IIFF", "buildKeyFrames", "[F[I", "buildKeyBounds", "getAttributeValues", "LNSString;[FI", "buildRect", "F[FI", "buildRectangles", "getKeyFrameParameter", "IFF", "insertKey", "LADXMLMotionPaths;", "addKeys", "LJavaUtilArrayList;", "(Ljava/util/ArrayList<Landroidx/constraintlayout/motion/widget/Key;>;)V", "addKey", "LADXKey;", "setPathMotionArc", "setup", "IIFJ", "toString", "readView", "setView", "setStartCurrentState", "setStartState", "LADXViewState;LADView;III", "rotate", "LADRect;LADRect;III", "LADRect;LADXConstraintSet;II", "getInterpolator", "LADContext;ILNSString;I", "setEndState", "setBothStates", "getAdjustedPosition", "F[F", "endTrigger", "Z", "interpolate", "LADView;FJLADXKeyCache;", "getDpDt", "FFF[F", "getPostLayoutDvDp", "FIIFF[F", "setDrawPath", "positionKeyframe", "LADView;LADXKeyPositionBase;FF[LNSString;[F", "getKeyFramePositions", "[I[F", "getKeyFrameInfo", "I[I", &ADXMotionController_TAG, "Ljava/util/ArrayList<Landroidx/constraintlayout/motion/widget/MLMotionPaths;>;", "Ljava/util/ArrayList<Landroidx/constraintlayout/motion/widget/Key;>;", "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/motion/utils/ViewTimeCycle;>;", "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/motion/utils/ViewSpline;>;", "Ljava/util/HashMap<Ljava/lang/String;Landroidx/constraintlayout/motion/utils/ViewOscillator;>;" };
  static const J2ObjcClassInfo _ADXMotionController = { "MotionController", "androidx.constraintlayout.motion.widget", ptrTable, methods, fields, 7, 0x1, 55, 65, -1, -1, -1, -1, -1 };
  return &_ADXMotionController;
}

@end

void ADXMotionController_initWithADView_(ADXMotionController *self, ADView *view) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->mTempRect_, new_ADRect_init());
  self->mCurveFitType_ = ADXKeyFrames_UNSET;
  JreStrongAssignAndConsume(&self->mStartMotionPath_, new_ADXMLMotionPaths_initPackagePrivate());
  JreStrongAssignAndConsume(&self->mEndMotionPath_, new_ADXMLMotionPaths_initPackagePrivate());
  JreStrongAssignAndConsume(&self->mStartPoint_, new_ADXMLMotionConstrainedPoint_initPackagePrivate());
  JreStrongAssignAndConsume(&self->mEndPoint_, new_ADXMLMotionConstrainedPoint_initPackagePrivate());
  self->mMotionStagger_ = JavaLangFloat_NaN;
  self->mStaggerOffset_ = 0;
  self->mStaggerScale_ = 1.0f;
  self->MAX_DIMENSION_ = 4;
  JreStrongAssignAndConsume(&self->mValuesBuff_, [IOSFloatArray newArrayWithLength:self->MAX_DIMENSION_]);
  JreStrongAssignAndConsume(&self->mMLMotionPaths_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&self->mVelocity_, [IOSFloatArray newArrayWithLength:1]);
  JreStrongAssignAndConsume(&self->mKeyList_, new_JavaUtilArrayList_init());
  self->mPathMotionArc_ = JreLoadStatic(ADXKey, UNSET);
  self->mTransformPivotTarget_ = JreLoadStatic(ADXKey, UNSET);
  JreStrongAssign(&self->mTransformPivotView_, nil);
  self->mQuantizeMotionSteps_ = JreLoadStatic(ADXKey, UNSET);
  self->mQuantizeMotionPhase_ = JavaLangFloat_NaN;
  JreStrongAssign(&self->mQuantizeMotionInterpolator_, nil);
  self->mNoMovement_ = false;
  [self setViewWithADView:view];
}

ADXMotionController *new_ADXMotionController_initWithADView_(ADView *view) {
  J2OBJC_NEW_IMPL(ADXMotionController, initWithADView_, view)
}

ADXMotionController *create_ADXMotionController_initWithADView_(ADView *view) {
  J2OBJC_CREATE_IMPL(ADXMotionController, initWithADView_, view)
}

float ADXMotionController_getPreCycleDistance(ADXMotionController *self) {
  int32_t pointCount = 100;
  IOSFloatArray *points = [IOSFloatArray arrayWithLength:2];
  float sum = 0;
  float mils = 1.0f / (pointCount - 1);
  double x = 0;
  double y = 0;
  for (int32_t i = 0; i < pointCount; i++) {
    float position = (i) * mils;
    double p = position;
    ADXEasing *easing = JreRetainedLocalValue(((ADXMLMotionPaths *) nil_chk(self->mStartMotionPath_))->mKeyFrameEasing_);
    float start = 0;
    float end = JavaLangFloat_NaN;
    for (ADXMLMotionPaths * __strong frame in nil_chk(self->mMLMotionPaths_)) {
      if (((ADXMLMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
        if (frame->time_ < position) {
          easing = frame->mKeyFrameEasing_;
          start = frame->time_;
        }
        else {
          if (JavaLangFloat_isNaNWithFloat_(end)) {
            end = frame->time_;
          }
        }
      }
    }
    if (easing != nil) {
      if (JavaLangFloat_isNaNWithFloat_(end)) {
        end = 1.0f;
      }
      float offset = (position - start) / (end - start);
      offset = (float) [easing getWithDouble:offset];
      p = offset * (end - start) + start;
    }
    [((ADXCurveFit *) nil_chk(IOSObjectArray_Get(nil_chk(self->mSpline_), 0))) getPosWithDouble:p withDoubleArray:self->mInterpolateData_];
    [((ADXMLMotionPaths *) nil_chk(self->mStartMotionPath_)) getCenterWithDouble:p withIntArray:self->mInterpolateVariables_ withDoubleArray:self->mInterpolateData_ withFloatArray:points withInt:0];
    if (i > 0) {
      JrePlusAssignFloatD(&sum, JavaLangMath_hypotWithDouble_withDouble_(y - IOSFloatArray_Get(points, 1), x - IOSFloatArray_Get(points, 0)));
    }
    x = IOSFloatArray_Get(points, 0);
    y = IOSFloatArray_Get(points, 1);
  }
  return sum;
}

void ADXMotionController_insertKeyWithADXMLMotionPaths_(ADXMotionController *self, ADXMLMotionPaths *point) {
  int32_t pos = JavaUtilCollections_binarySearchWithJavaUtilList_withId_(self->mMLMotionPaths_, point);
  if (pos == 0) {
    ADLog_eWithNSString_withNSString_(ADXMotionController_TAG, JreStrcat("$F$", @" KeyPath position \"", ((ADXMLMotionPaths *) nil_chk(point))->position_, @"\" outside of range"));
  }
  [((JavaUtilArrayList *) nil_chk(self->mMLMotionPaths_)) addWithInt:-pos - 1 withId:point];
}

void ADXMotionController_readViewWithADXMLMotionPaths_(ADXMotionController *self, ADXMLMotionPaths *motionPaths) {
  [((ADXMLMotionPaths *) nil_chk(motionPaths)) setBoundsWithFloat:(int32_t) [((ADView *) nil_chk(self->mView_)) getX] withFloat:(int32_t) [((ADView *) nil_chk(self->mView_)) getY] withFloat:[((ADView *) nil_chk(self->mView_)) getWidth] withFloat:[((ADView *) nil_chk(self->mView_)) getHeight]];
}

id<ADInterpolator> ADXMotionController_getInterpolatorWithADContext_withInt_withNSString_withInt_(ADContext *context, int32_t type, NSString *interpolatorString, int32_t id_) {
  ADXMotionController_initialize();
  {
    ADXEasing *easing;
    switch (type) {
      case ADXMotionController_SPLINE_STRING:
      easing = ADXEasing_getInterpolatorWithNSString_(interpolatorString);
      return create_ADXMotionController_1_initWithADXEasing_(easing);
      case ADXMotionController_INTERPOLATOR_REFERENCE_ID:
      return ADAnimationUtils_loadInterpolatorWithADContext_withInt_(context, id_);
      case ADXMotionController_EASE_IN_OUT:
      return create_ADAccelerateDecelerateInterpolator_init();
      case ADXMotionController_EASE_IN:
      return create_ADAccelerateInterpolator_init();
      case ADXMotionController_EASE_OUT:
      return create_ADDecelerateInterpolator_init();
      case ADXMotionController_LINEAR:
      return nil;
      case ADXMotionController_BOUNCE:
      return create_ADBounceInterpolator_init();
      case ADXMotionController_OVERSHOOT:
      return create_ADOvershootInterpolator_init();
    }
  }
  return nil;
}

float ADXMotionController_getAdjustedPositionWithFloat_withFloatArray_(ADXMotionController *self, float position, IOSFloatArray *velocity) {
  if (velocity != nil) {
    *IOSFloatArray_GetRef(velocity, 0) = 1;
  }
  else if (self->mStaggerScale_ != 1.0) {
    if (position < self->mStaggerOffset_) {
      position = 0;
    }
    if (position > self->mStaggerOffset_ && position < 1.0) {
      JreMinusAssignFloatF(&position, self->mStaggerOffset_);
      JreTimesAssignFloatF(&position, self->mStaggerScale_);
      position = JavaLangMath_minWithFloat_withFloat_(position, 1.0f);
    }
  }
  float adjusted = position;
  ADXEasing *easing = JreRetainedLocalValue(((ADXMLMotionPaths *) nil_chk(self->mStartMotionPath_))->mKeyFrameEasing_);
  float start = 0;
  float end = JavaLangFloat_NaN;
  for (ADXMLMotionPaths * __strong frame in nil_chk(self->mMLMotionPaths_)) {
    if (((ADXMLMotionPaths *) nil_chk(frame))->mKeyFrameEasing_ != nil) {
      if (frame->time_ < position) {
        easing = frame->mKeyFrameEasing_;
        start = frame->time_;
      }
      else {
        if (JavaLangFloat_isNaNWithFloat_(end)) {
          end = frame->time_;
        }
      }
    }
  }
  if (easing != nil) {
    if (JavaLangFloat_isNaNWithFloat_(end)) {
      end = 1.0f;
    }
    float offset = (position - start) / (end - start);
    float new_offset = (float) [easing getWithDouble:offset];
    adjusted = new_offset * (end - start) + start;
    if (velocity != nil) {
      *IOSFloatArray_GetRef(velocity, 0) = (float) [easing getDiffWithDouble:offset];
    }
  }
  return adjusted;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADXMotionController)

J2OBJC_NAME_MAPPING(ADXMotionController, "androidx.constraintlayout.motion.widget", "ADX")

@implementation ADXMotionController_1

- (instancetype)initWithADXEasing:(ADXEasing *)capture$0 {
  ADXMotionController_1_initWithADXEasing_(self, capture$0);
  return self;
}

- (float)getInterpolationWithFloat:(float)v {
  return (float) [((ADXEasing *) nil_chk(val$easing_)) getWithDouble:v];
}

- (void)dealloc {
  RELEASE_(val$easing_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "F", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADXEasing:);
  methods[1].selector = @selector(getInterpolationWithFloat:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$easing_", "LADXEasing;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADXEasing;", "getInterpolation", "F", "LADXMotionController;", "getInterpolatorWithADContext:withInt:withNSString:withInt:" };
  static const J2ObjcClassInfo _ADXMotionController_1 = { "", "androidx.constraintlayout.motion.widget", ptrTable, methods, fields, 7, 0x8000, 2, 1, 3, -1, 4, -1, -1 };
  return &_ADXMotionController_1;
}

@end

void ADXMotionController_1_initWithADXEasing_(ADXMotionController_1 *self, ADXEasing *capture$0) {
  JreStrongAssign(&self->val$easing_, capture$0);
  NSObject_init(self);
}

ADXMotionController_1 *new_ADXMotionController_1_initWithADXEasing_(ADXEasing *capture$0) {
  J2OBJC_NEW_IMPL(ADXMotionController_1, initWithADXEasing_, capture$0)
}

ADXMotionController_1 *create_ADXMotionController_1_initWithADXEasing_(ADXEasing *capture$0) {
  J2OBJC_CREATE_IMPL(ADXMotionController_1, initWithADXEasing_, capture$0)
}
